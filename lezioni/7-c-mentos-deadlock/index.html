<!doctype html><html lang=it><head><meta charset=utf-8><meta name=author content="SeekBytes"><meta name=viewport content="width=device-width,initial-scale=1"><title>Lezione 7.C - MentOS Deadlock</title><link href=https://seekbytes.github.io/oslab/css/style.css rel=stylesheet type=text/css><link href=https://seekbytes.github.io/oslab/css/syntax.css rel=stylesheet type=text/css><link href=https://seekbytes.github.io/oslab/css/print.css rel=stylesheet media=print type=text/css></head><body class=flex><div class=navbar-lat><div class=links><h2>Indice</h2><nav id=TableOfContents><ul><li><a href=#aspetti-teorici>Aspetti teorici</a></li><li><a href=#algoritmo-del-banchiere>Algoritmo del banchiere</a><ul><li><a href=#notazioni-e-variabili>Notazioni e variabili</a></li><li><a href=#pseudocodice>Pseudocodice</a><ul><li><a href=#richiesta-di-risorsa>Richiesta di risorsa</a></li><li><a href=#controllo-stato-safe>Controllo stato safe</a></li></ul></li></ul></li><li><a href=#prevenzione-del-deadlock-su-mentos>Prevenzione del deadlock su MentOS</a><ul><li><a href=#libreria-arr_math>Libreria arr_math</a></li><li><a href=#esercizio>Esercizio</a><ul><li><a href=#preparazione>Preparazione</a></li></ul></li></ul></li></ul></nav><h3>Contenuti</h3><ul><li><a href=https://seekbytes.github.io/oslab/lezioni/0-sistemi-operativi-laboratorio/>Lezione 0 - Introduzione a Sistemi Operativi Laboratorio</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/1-a-concetti-fondamentali/>Lezione 1.A - Concetti fondamentali: Processi e Programmi</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/1-b-file-system/>Lezione 1.B - Concetti fondamentali: File System</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/2-processi/>Lezione 2 - Processi</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/3-mentos/>Lezione 3.A - Fondamentali di MentOS</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/3-b-mentos-scheduling/>Lezione 3.B - MentOS Scheduling</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/4-a-semafori-ipc/>Lezione 4.A - IPC e Semafori</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/4-b-segnali-ipc/>Lezione 4.B - IPC e Segnali</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/5-memoria-condivisa-coda-di-messaggi/>Lezione 5 - Memoria condivisa e coda di messaggi</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/6-pipe-fifo/>Lezione 6 - Pipe e FIFO</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/7-a-struttura-mentos/>Lezione 7.A - Struttura di MentOS</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/7-b-mentos-system-call/>Lezione 7.B - System Call MentOS</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/7-c-mentos-deadlock/>Lezione 7.C - MentOS Deadlock</a></li></ul><a href=../>Sezione principale</a></div></div><div class=content><a href=https://seekbytes.github.io/oslab/ id=returnBack>Ritorna indietro</a><h1>Lezione 7.C - MentOS Deadlock</h1><p class=details>Pubblicato il 4/26/22 da – 1006 parole</p><h2 id=aspetti-teorici>Aspetti teorici</h2><div class=definition><h3>Definizione di Deadlock</h3>Stato di un sistema concorrente con risorse condivise tra processi, in cui almeno un singolo processo è in attesa di un&rsquo;acquisizione di risorse che può essere rilasciata da un altro processo senza risoluzione.</div><p>Se vuoi evitare il deadlock devi prevenire il verificarsi di almeno di una delle seguenti condizioni:</p><ul><li>mutua esclusione</li><li>hold and wait</li><li>no pre-emption</li><li>attesa circolare</li></ul><div class=definition><h3>Definizione di Stato Safe</h3>Lo stato del sistema è sicuro se è possibile trovare una sequenza di allocazioni di risorse che soddisfano i requisiti delle risorse dei compiti, altrimenti non è sicuro.</div><p>La prevenzione però è possibile solamente nel momento in cui si conoscono quante risorse devono essere allocate e in che modo. Non molto semplice da fare.</p><p>Metodologie che sono basate sul concetto dello stato unsafe:</p><ul><li>Prevenzione dinamica: controlla ogni richiesta di allocazione se porta ad uno stato non sicuro;</li><li>Rilevazione: rileva solamente quando accade uno stato non sicuro;</li></ul><p>Per esempio: algoritmo del banchiere.</p><h2 id=algoritmo-del-banchiere>Algoritmo del banchiere</h2><p>Idea principale dell&rsquo;algoritmo del banchiere: soddisferò la tua richiesta solo se sono sicuro di soddisfare le richieste che altri possono chiedere.
Non è così generoso perché considera il limite superiore delle risorse richieste => Svantaggio: possibile starvation.</p><p>Metodologie alternative:</p><ul><li>Prevenzione statica: vincoli di progettazione per falsificare le condizioni di deadlock;</li><li>Rilevamento e recupero: rollback o, nel peggiore dei casi, riavvio del sistema;</li><li>Non gestito: i programmatori devono scrivere del buon codice (es. Linux);</li></ul><h3 id=notazioni-e-variabili>Notazioni e variabili</h3><ul><li><code>n</code>: Numero attuale di risorse nel sistema.</li><li><code>m</code>: Numero attuale di tipi di risorse nel sistema.</li><li><code>req_task</code>: Processo che esegue la richiesta della risorsa.</li><li><code>req_vec[m]</code>: Istanze di risorsa richieste dal task req.</li><li><code>available[m]</code>: Numero di istanze di risorse disponibili per ogni tipo di risorsa.</li><li><code>max[n][m]</code>: Numero massimo di istanze di risorse che ogni task può richiedere;</li><li><code>alloc[n][m]</code>: Attuale allocazione di istanze di risorse per ogni compito.</li><li><code>need[n][m]</code>: Attuale necessità di istanze di risorse per ogni compito.<br><code>need[i][j] = max[i][j] - alloc[i][j]</code>.</li></ul><h3 id=pseudocodice>Pseudocodice</h3><h4 id=richiesta-di-risorsa>Richiesta di risorsa</h4><pre tabindex=0><code class=language-pseudocode data-lang=pseudocode>if req vec &gt; need[req task] then
	error()
end if
if req vec &gt; available then
	wait()
end if
available = available - req vec
alloc[req task] = alloc[req task] + req vec
need[req task] = need[req task] - req vec
if !safe state() then
	available = available + req vec
	alloc[req task] = alloc[req task] - req vec
	need[req task] = need[req task] + req vec
end if</code></pre><h4 id=controllo-stato-safe>Controllo stato safe</h4><pre tabindex=0><code class=language-pseudocode data-lang=pseudocode>work[m] = available; finish[n] = (0,...,0)
while finish[] != (1,...,1) do
	for i=0 to n do
		if !finish[i] and work &gt;= need[i] then
			break
		end if
	end for
	if i == N then
		return false // UNSAFE
	else
		work = work + alloc[i]
		finish[i] = 1
	end if
end while
return true // SAFE</code></pre><h2 id=prevenzione-del-deadlock-su-mentos>Prevenzione del deadlock su MentOS</h2><p>La prevenzione dei deadlock non è facile da eseguire, perché abbiamo bisogno di conoscere in anticipo le informazioni sull&rsquo;esecuzione dei compiti. In particolare, abbiamo bisogno di riempire le matrici available, max, alloc, need.</p><p>Cosa dobbiamo fare per ottenere le matrici?</p><ul><li>available: necessità di una lista di risorse create;</li><li>max: necessità di sapere per ogni compito quali sono le risorse che gli interessano.</li><li>alloc: necessità di sapere a quale processo è stata assegnata una risorsa.</li><li>need: necessità di una libreria per gestire le matrici (anche per l&rsquo;algoritmo
stesso).</li></ul><p>Ipotesi fatte:</p><ul><li>Ogni semaforo creato appartiene ad una risorsa esistente.</li><li>Ogni risorsa può essere utilizzata dal processo che l&rsquo;ha creata e dai processi figli.</li></ul><p>Cosa è stato implementato:</p><ul><li>Definizione della resource_t con riferimento al compito che la possiede.</li><li>Creazione della lista globale delle risorse create.</li><li>Elenco delle risorse per le quali i compiti sono interessati, nella task_struct.</li><li>Copia di questo elenco nella struct del task figlio durante il fork della syscall.</li><li>Creazione di risorse durante la creazione del semaforo nella syscall lato kernel.</li><li>Implementazione della libreria matematica arr.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>resource</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>/// Resource index. The resources indexes has to be continuous: 0, 1, ... M.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>size_t</span> <span class=n>rid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=c1>/// List head for resources list.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>list_head</span> <span class=n>resources_list</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=c1>/// Number of instances of this resource. For now, always 1.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>size_t</span> <span class=n>n_instances</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=c1>/// If the resource has been assigned, it points to the task assigned,
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>/// otherwise NULL.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>task_struct</span> <span class=o>*</span><span class=n>assigned_task</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=c1>/// Number of instances assigned to assigned task.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>size_t</span> <span class=n>assigned_instances</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>resource_t</span><span class=p>;</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>task_struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=p>...</span>
</span></span><span class=line><span class=cl>	<span class=c1>/// Array of resource pointers that task need for.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>struct</span> <span class=n>resource</span> <span class=o>*</span><span class=n>resources</span><span class=p>[</span><span class=n>TASK_RESOURCE_MAX_AMOUNT</span><span class=p>];</span>
</span></span><span class=line><span class=cl>	<span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>task_struct</span><span class=p>;</span></span></span></code></pre></div><h3 id=libreria-arr_math>Libreria arr_math</h3><p>L&rsquo;implementazione dell&rsquo;algoritmo di Banker ha bisogno di gestire matrici e array. Potete trovare la definizione di <code>arr_math</code> in <code>mentos/inc/experimental/math/arr_math.h</code>. Quello che segue è un riassunto delle definizioni:</p><ul><li><p><code>uint32_t *all(uint32 t *dst, uint32 t value, size_t length);</code><br>Inizializza l&rsquo;array di destinazione con un valore.</p></li><li><p><code>uint32_t *arr sub(uint32 t *left, const uint32 t *right, size_t lunghezza);</code><br>Sottrazione degli elementi dell&rsquo;array, salvata nel puntatore <code>left</code>.</p></li><li><p><code>uint32_t *arr add(uint32 t *left, const uint32 t *right, size_t lunghezza);</code><br>Addizione di elementi dell&rsquo;array, salvata nel puntatore <code>left</code>.</p></li><li><p><code>bool_t arr_g_any(const uint32 t *left, const uint32 t *right, size_t length);</code>
Controlla che almeno un elemento dell&rsquo;array sia maggiore del rispettivo
altro. Es. [1, 1, 6] g_any[1, 2, 3] = true</p></li><li><p><code>bool_t arr_g(const uint32 t *left, const uint32 t *right, size_t lunghezza);</code>
Controlla che tutti gli elementi dell&rsquo;array siano maggiori degli altri. Es. [2, 3, 4] g_all[1, 2, 3] = true</p></li><li><p><code>arr_ge_any</code>: maggiore o uguale ad almeno uno.</p></li><li><p><code>arr_ge</code>: maggiore o uguale a tutti gli elementi.</p></li><li><p><code>arr_l_any</code>, <code>arr_le_any</code>: minore (e meno o uguale) ad almeno uno.</p></li><li><p><code>arr_l</code>, <code>arr_le</code>: meno e meno o uguale a tutti gli elementi.</p></li><li><p><code>arr_e</code>, <code>arr_ne</code>: uguale e non uguale a tutti gli elementi</p></li></ul><h3 id=esercizio>Esercizio</h3><h4 id=preparazione>Preparazione</h4><p><strong>Richiede</strong>: syscall dei semafori e algoritmi di scheduling implementati.</p><ol><li><code>cd &lt;mentos-main-dir></code></li><li><code>git checkout --track origin/feature/Feature-DeadlockExercise</code></li><li><code>git pull</code></li><li>Prepara MentOS con l&rsquo;implementazione di un algoritmo di scheduling e i semafori.<br><code>mentos/src/process/scheduler_algorithm.c</code><br><code>src/experimental/smart_sem_user.c</code></li></ol><p><strong>Esercizio</strong>: implementare l&rsquo;algoritmo del banchiere in MentOS partendo dal template dato <code>mentos/src/experimental/deadlock prevention.c</code></p><p><strong>Controllare i risultati</strong>:
Costruire il progetto:</p><ol><li><code>cd &lt;mentos-main-dir></code></li><li><code>mkdir build && cd build</code></li><li><code>cmake -DENABLE_DEADLOCK_PREVENTION=ON ..</code></li><li>Costruire: <code>make</code></li><li>Esegui: <code>make qemu</code>
Controllare nella console di debug per la prevenzione dei deadlock deterministica simulazione.Provate la riga di comando della shell <code>deadlock [-i &lt;iterazioni>]</code> per testare la prevenzione dei deadlock in processi reali.</li></ol><footer><p>Contenuto basato sulle slide del corso di Sistemi Operativi A.A Laboratorio 2021-2022 UniVR. Copyright degli autori delle slide originali.
<a href=https://github.com/seekbytes/oslab/edit/main/content/lezioni/7_c_MentOS_deadlock.md>Modifica questa pagina</a></p></footer></div></body></html>