<!doctype html><html lang=it><head><meta charset=utf-8><meta name=author content="SeekBytes"><meta name=viewport content="width=device-width,initial-scale=1"><title>Lezione 3.A - Fondamentali di MentOS</title><link href=https://seekbytes.github.io/oslab/css/style.css rel=stylesheet type=text/css><link href=https://seekbytes.github.io/oslab/css/syntax.css rel=stylesheet type=text/css><link href=https://seekbytes.github.io/oslab/css/print.css rel=stylesheet media=print type=text/css><meta name=description content="Prima parte: introduzione a MentOS e come funziona."><meta property="og:locale" content="it"><meta name=robots content="index,follow"><meta name=googlebot content="index,follow"></head><body class=flex><div class=navbar-lat><div class=links><h2>Indice</h2><nav id=TableOfContents><ul><li><a href=#che-cosa-è>Che cosa è?</a></li><li><a href=#concetti-fondamentali>Concetti fondamentali</a><ul><li><a href=#registri-cpu>Registri CPU</a><ul><li><a href=#registri-general-purpose>Registri General Purpose</a></li></ul></li><li><a href=#registri-di-stato-e-di-controllo>Registri di stato e di controllo</a></li><li><a href=#privilegi>Privilegi</a></li><li><a href=#programmable-interrupt-controller-pic>Programmable Interrupt Controller (PIC)</a></li><li><a href=#organizzazione-della-memoria>Organizzazione della memoria</a></li></ul></li><li><a href=#kernel-doubly-linked-list>Kernel Doubly-Linked list</a><ul><li><a href=#funzioni-di-supporto>Funzioni di supporto</a><ul><li><a href=#list_entry>List_entry</a></li><li><a href=#list_for_each>List_for_each</a></li></ul></li></ul></li></ul></nav><h3>Contenuti</h3><ul><li><a href=https://seekbytes.github.io/oslab/lezioni/0-sistemi-operativi-laboratorio/>Lezione 0 - Introduzione a Sistemi Operativi Laboratorio</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/1-a-concetti-fondamentali/>Lezione 1.A - Concetti fondamentali: Processi e Programmi</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/1-b-file-system/>Lezione 1.B - Concetti fondamentali: File System</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/2-processi/>Lezione 2 - Processi</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/3-mentos/>Lezione 3.A - Fondamentali di MentOS</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/3-b-mentos-scheduling/>Lezione 3.B - MentOS Scheduling</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/4-a-semafori-ipc/>Lezione 4.A - IPC e Semafori</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/4-b-segnali-ipc/>Lezione 4.B - IPC e Segnali</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/5-memoria-condivisa-coda-di-messaggi/>Lezione 5 - Memoria condivisa e coda di messaggi</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/6-pipe-fifo/>Lezione 6 - Pipe e FIFO</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/7-a-struttura-mentos/>Lezione 7.A - Struttura di MentOS</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/7-b-mentos-system-call/>Lezione 7.B - System Call MentOS</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/7-c-mentos-deadlock/>Lezione 7.C - MentOS Deadlock</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/8-mentos-buddy-system/>Lezione 8 - MentOS Buddy System</a></li></ul><a href=../>Sezione principale</a></div></div><div class=content><a href=https://seekbytes.github.io/oslab/ id=returnBack>Ritorna indietro</a><h1>Lezione 3.A - Fondamentali di MentOS</h1><p class=details>Pubblicato il 11/29/21 da SeekBytes – 1078 parole</p><h2 id=che-cosa-è>Che cosa è?</h2><p>MentOS è un sistema operativo open-source utilizzato per scopi didattici. MentOS può essere scaricato dalla repository Github gratuita: <a href=https://github.com/mentos/>github.com/MentOS</a>. L&rsquo;obiettivo di MentOS è di fornire un ambiente progettuale che sia abbastanza realistico da mostrare come funziona un vero sistema operativo, ma, allo stesso tempo, abbastanza semplice che gli studenti possano capirlo e modificarlo in modo significativo.</p><p>Ma se ci sono così tanti sistemi operativi, perché qualcuno ha scritto MentOS? È vero, ci sono molti sistemi operativi per l&rsquo;istruzione, MA quanti di loro seguono le linee guida definita da Linux? MentOS mira ad avere le stesse strutture dati e algoritmi di Linux. Ha un codice sorgente ben documentato, e puoi compilarlo sul tuo portatile in pochi secondi! Se sei un principiante nello sviluppo di sistemi operativi, forse MentOS è il sistema operativo giusto per iniziare.</p><h2 id=concetti-fondamentali>Concetti fondamentali</h2><h3 id=registri-cpu>Registri CPU</h3><p>Esistono tre tipi di registri nella CPU:</p><ul><li>registri di general-purpose</li><li>registri segment</li><li>registri di stato e di controllo</li></ul><h4 id=registri-general-purpose>Registri General Purpose</h4><p>Gli otto registri di uso generale a 32 bit sono usati per contenere operandi per operazioni logiche e aritmetiche, operandi per il calcolo degli indirizzi e puntatori di memoria. Quanto segue mostra per cosa sono usati:</p><ul><li><code>EAX</code>: Accumulatore per operandi e dati dei risultati;</li><li><code>EBX</code>: puntatore ai dati nel segmento DS;</li><li><code>ECX</code>: Contatore per le operazioni di loop;</li><li><code>EDX</code>: puntatore I/O;</li><li><code>ESI</code>: Puntatore ai dati nel segmento indicato dal registro DS;</li><li><code>EDI</code>: Puntatore ai dati nel segmento indicato dal registro ES;</li><li><code>EBP</code>: puntatore ai dati sullo stack (nel segmento SS);</li><li><code>ESP</code>: puntatore allo stack (nel segmento SS).</li></ul><h3 id=registri-di-stato-e-di-controllo>Registri di stato e di controllo</h3><p>I due registri di controllo di stato a 32 bit sono usati per:</p><ul><li><code>EIP</code>: puntatore di istruzione (noto anche come &ldquo;program counter&rdquo;);</li><li><code>EFLAGS</code>: Mantenere un gruppo di flag di stato, di controllo e di sistema.</li></ul><p>Tabella con le flag:</p><table><thead><tr><th>Bit</th><th>Descrizione</th><th>Categoria</th></tr></thead><tbody><tr><td>0</td><td>Carry Flag</td><td>Status</td></tr><tr><td>2</td><td>Parity Flag</td><td>Status</td></tr><tr><td>4</td><td>Adjust Flag</td><td>Status</td></tr><tr><td>6</td><td>Zero Flag</td><td>Status</td></tr><tr><td>7</td><td>Sign Flag</td><td>Status</td></tr><tr><td>8</td><td>Trap Flag</td><td>Controllo</td></tr><tr><td>9</td><td>Interrupt enable flag</td><td>Controllo</td></tr><tr><td>10</td><td>Direction flag</td><td>Controllo</td></tr><tr><td>11</td><td>Overflow flag</td><td>Status</td></tr><tr><td>12-13</td><td>Privilege level</td><td></td></tr><tr><td>&mldr;.</td><td></td><td></td></tr></tbody></table><h3 id=privilegi>Privilegi</h3><p>Ci sono quattro livelli di privilegio, numerati da 0 (il più privilegiato) a 3 (il meno privilegiato).</p><p>In qualsiasi momento, una CPU x86 è in esecuzione in un livello di privilegio specifico, che determina quale codice può e non può essere eseguito.
Quale delle seguenti operazioni può fare quando la CPU è in modalità utente?</p><ol><li>aprire un file</li><li>stampare sullo schermo;</li><li>allocare la memoria.</li></ol><p>Ogni volta che la CPU cambia livello di privilegio, si verifica un cambio di contesto! Esempio di eventi che fanno cambiare modalità di esecuzione alla CPU: Un clic del mouse, la digitazione di un carattere sulla tastiera, una chiamata di sistema&mldr;</p><h3 id=programmable-interrupt-controller-pic>Programmable Interrupt Controller (PIC)</h3><p>Un controllore di interrupt programmabile è un componente che combina diversi interrupt
su una o più linee della CPU.</p><p>Esempio di richiesta di interrupt:</p><ul><li>viene premuto un tasto della tastiera</li><li>Il PIC alza la linea INTR e presenta IRQ 1 alla CPU</li><li>La CPU salta in modalità Kernel per gestire la richiesta di interrupt</li><li>La CPU legge dalla tastiera il tasto premuto</li><li>La CPU invia indietro ACK per notificare che IRQ 1 è stato gestito</li><li>La CPU torna in modalità utente</li></ul><p>Il timer è un componente hardware a parte della CPU. Ad una frequenza fissa, il timer alza un segnale collegato all&rsquo;IRQ 0 del PIC. Linux fissa la frequenza del timer a 100 Hz. La CPU esegue un processo utente per un massimo di 10 millisecondi, poi il Kernel riprende il controllo della CPU.</p><h3 id=organizzazione-della-memoria>Organizzazione della memoria</h3><p>Il kernel applica la memoria virtuale per mappare gli indirizzi virtuali agli indirizzi fisici. La RAM è virtualmente divisa in spazio Kernel (1GB) e spazio utente (3GB). La CPU in Ring 0 ha visibilità su tutta la RAM. La CPU nel Ring 3 ha visibilità solamente dello spazio utente.</p><h2 id=kernel-doubly-linked-list>Kernel Doubly-Linked list</h2><p>I kernel dei sistemi operativi, come molti altri programmi, hanno spesso bisogno di mantenere elenchi di strutture di dati. Per ridurre la quantità di codice duplicato codice, gli sviluppatori del kernel hanno creato un&rsquo;implementazione standard di liste circolari a doppio link.</p><p>Pro:</p><ul><li>Più sicuro/veloce della propria implementazione ad-hoc.</li><li>Viene fornito con diverse funzioni già pronte all&rsquo;uso.</li></ul><p>Contro:</p><ul><li>La manipolazione dei puntatori può essere difficile.</li></ul><p>Per utilizzare il meccanismo della lista, gli sviluppatori del kernel hanno definito la struttura dei dati della testa della lista come segue:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>list_head</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>list_head</span> <span class=o>*</span><span class=n>next</span><span class=p>,</span> <span class=o>*</span><span class=n>prev</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>list_head_t</span><span class=p>;</span></span></span></code></pre></div><p>Una list_head rappresenta un nodo di una lista!</p><p>Per utilizzare la funzione di lista di Linux, abbiamo solo bisogno di incorporare una testa di lista all&rsquo;interno delle strutture che compongono la lista.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>mystruct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>//...
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>list_head_t</span> <span class=n>list</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=c1>//...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span></span></span></code></pre></div><p>Le istanze di mystruct possono ora essere collegate per creare una lista double-linked!</p><p>La testa di una lista deve essere una struttura di tipo <code>list_head_t</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>mystruct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>//...
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>list_head_t</span> <span class=n>list</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=c1>//...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span></span></span></code></pre></div><p>La head è sempre presente nella lista circolare. Se una lista è vuota, allora esise solo la head.</p><h3 id=funzioni-di-supporto>Funzioni di supporto</h3><p>Funzioni di supporto da usare con una lista circolare a doppio link.</p><ul><li><p><code>list_head_empty(list head t *head)</code>:<br>Restituisce un valore diverso da zero se la lista data è vuota.</p></li><li><p><code>list_head_add(list_head_t *new, list_head_t *listnode)</code>:<br>Questa funzione aggiunge la nuova voce immediatamente dopo il listnode.</p></li><li><p><code>list_head_add_tail(list_head_t *new, list_head_t *listnode)</code>:<br>Questa funzione aggiunge la nuova voce immediatamente prima del listnode.</p></li><li><p><code>list_head_del(list_head_t *entry):</code><br>La voce data viene rimossa dalla lista.</p></li></ul><h4 id=list_entry>List_entry</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=p>(</span><span class=n>type</span> <span class=o>*</span><span class=p>)</span> <span class=n>list_entry</span><span class=p>(</span><span class=n>list_head_t</span> <span class=o>*</span><span class=n>ptr</span><span class=p>,</span> <span class=n>struct_type</span><span class=p>,</span> <span class=n>field_name</span><span class=p>)</span></span></span></code></pre></div><p>Restituisce la struct che incorpora una testa di lista. In dettaglio:</p><ul><li><code>ptr</code> è un puntatore ad una testa di lista t;</li><li><code>type</code> of struct è il nome del tipo della struct che incorpora una list_head_t;</li><li><code>field</code> name è il nome della testa di lista t puntata all&rsquo;interno della struct.</li></ul><details><summary><b>Esempio di come utilizzare la list_entry.</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// Example showing how to get the first mystruct from a list
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>list_head_t</span> <span class=o>*</span><span class=n>listptr</span> <span class=o>=</span> <span class=n>head</span><span class=p>.</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>mystruct</span> <span class=o>*</span><span class=n>item</span> <span class=o>=</span> <span class=n>list_entry</span><span class=p>(</span><span class=n>listptr</span><span class=p>,</span> <span class=k>struct</span> <span class=n>mystruct</span><span class=p>,</span> <span class=n>list</span><span class=p>);</span></span></span></code></pre></div></details><h4 id=list_for_each>List_for_each</h4><p>Itera su ogni elemento di una lista doppiamente collegata. In dettaglio:</p><ul><li><code>ptr</code> è un puntatore variabile libero di tipo <code>list_head_t</code>;</li><li><code>head</code> è un puntatore al nodo di testa di una lista.</li></ul><p>Partendo dal primo elemento della lista, ad ogni chiamata <code>ptr</code> viene impostato con l
l&rsquo;indirizzo del prossimo elemento della lista fino a quando non viene raggiunta la sua testa.</p><details><summary><b>Esempio di come utilizzare la list_for_each</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>list_head_t</span> <span class=o>*</span><span class=n>ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>mystruct</span> <span class=o>*</span><span class=n>entry</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// Inter over each mystruct item in list
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>list_for_each</span><span class=p>(</span><span class=n>ptr</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>head</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>entry</span> <span class=o>=</span> <span class=n>list_entry</span><span class=p>(</span><span class=n>ptr</span><span class=p>,</span> <span class=k>struct</span> <span class=n>mystruct</span><span class=p>,</span> <span class=n>list</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></details><footer><p>Contenuto basato sulle slide del corso di Sistemi Operativi A.A Laboratorio 2021-2022 UniVR. Copyright degli autori delle slide originali.
<a href=https://github.com/seekbytes/oslab/edit/main/content/lezioni/3_mentos.md>Modifica questa pagina</a></p></footer></div></body></html>