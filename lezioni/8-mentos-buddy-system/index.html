<!doctype html><html lang=it><head><meta charset=utf-8><meta name=author content="SeekBytes"><meta name=viewport content="width=device-width,initial-scale=1"><title>Lezione 8 - MentOS Buddy System</title><link href=https://seekbytes.github.io/oslab/css/style.css rel=stylesheet type=text/css><link href=https://seekbytes.github.io/oslab/css/syntax.css rel=stylesheet type=text/css><link href=https://seekbytes.github.io/oslab/css/print.css rel=stylesheet media=print type=text/css><meta name=description content="Gestione della memoria in MentOS, comprende strutture dati della memoria e buddy system."><meta property="og:locale" content="it"><meta name=robots content="index,follow"><meta name=googlebot content="index,follow"></head><body class=flex><div class=navbar-lat><div class=links><h2>Indice</h2><nav id=TableOfContents><ul><li><a href=#gestione-della-memoria-fisica>Gestione della memoria fisica</a><ul><li><a href=#page-descriptor>Page descriptor</a></li><li><a href=#zone-descriptor>Zone descriptor</a></li><li><a href=#zoned-page-frame-allocator>Zoned page frame allocator</a></li></ul></li><li><a href=#buddy-system>Buddy system</a><ul><li><a href=#stato-iniziale>Stato iniziale</a></li><li><a href=#algoritmo-alloc_pages>Algoritmo alloc_pages</a><ul><li><a href=#soddisfacimento-della-richiesta>Soddisfacimento della richiesta</a></li><li><a href=#rimuovere-un-blocco-di-pagine-libere>Rimuovere un blocco di pagine libere</a></li><li><a href=#splitting-del-blocco>Splitting del blocco</a></li></ul></li><li><a href=#free_pages>free_pages</a><ul><li><a href=#ricerca-di-un-blocco-sufficientemente-grande-a-soddisfare-la-richiesta>Ricerca di un blocco sufficientemente grande a soddisfare la richiesta</a></li></ul></li></ul></li><li><a href=#gestione-della-memoria-virtuale>Gestione della memoria virtuale</a><ul><li><a href=#memory-management-unit>Memory Management Unit</a></li><li><a href=#memory-descriptor>Memory descriptor</a></li><li><a href=#segment-descriptor>Segment descriptor</a></li></ul></li></ul></nav><h3>Contenuti</h3><ul><li><a href=https://seekbytes.github.io/oslab/lezioni/0-sistemi-operativi-laboratorio/>Lezione 0 - Introduzione a Sistemi Operativi Laboratorio</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/1-a-concetti-fondamentali/>Lezione 1.A - Concetti fondamentali: Processi e Programmi</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/1-b-file-system/>Lezione 1.B - Concetti fondamentali: File System</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/2-processi/>Lezione 2 - Processi</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/3-mentos/>Lezione 3.A - Fondamentali di MentOS</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/3-b-mentos-scheduling/>Lezione 3.B - MentOS Scheduling</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/4-a-semafori-ipc/>Lezione 4.A - IPC e Semafori</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/4-b-segnali-ipc/>Lezione 4.B - IPC e Segnali</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/5-memoria-condivisa-coda-di-messaggi/>Lezione 5 - Memoria condivisa e coda di messaggi</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/6-pipe-fifo/>Lezione 6 - Pipe e FIFO</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/7-a-struttura-mentos/>Lezione 7.A - Struttura di MentOS</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/7-b-mentos-system-call/>Lezione 7.B - System Call MentOS</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/7-c-mentos-deadlock/>Lezione 7.C - MentOS Deadlock</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/8-mentos-buddy-system/>Lezione 8 - MentOS Buddy System</a></li></ul><a href=../>Sezione principale</a></div></div><div class=content><a href=https://seekbytes.github.io/oslab/ id=returnBack>Ritorna indietro</a><h1>Lezione 8 - MentOS Buddy System</h1><p class=details>Pubblicato il 5/3/22 da SeekBytes – 1523 parole</p><h2 id=gestione-della-memoria-fisica>Gestione della memoria fisica</h2><p>In un sistema a 32 bit, i 4GB di spazio di indirizzamento della RAM sono divisi in pagine frammentate. Il processore x86 nella modalità 32 bit supporta pagine di 4KB, 2MB oppure 4MB. 4 Kybte è la tipica dimensione di una pagina frammentata.</p><p>Per il kernel, le pagine frammentate nella memoria fisica sono l&rsquo;unità base per la gestione della memoria.</p><h3 id=page-descriptor>Page descriptor</h3><p>Il kernel deve tenere traccia dello stato corrente di ogni pagina. Per esempio, deve determinare se una pagina: è libera, contiene alcune strutture o codice del kernel, se è associata ad un processo utente.</p><p>La struttura <code>page_t</code> mantiene l&rsquo;informazione di stato di una pagina:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>page_t</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>_count</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>private</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>list_head</span> <span class=n>lru</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=c1>// continue
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></div><p>Attributi di una pagina:</p><ul><li><code>_count</code>: se è impostata ad 1, la pagina corrispondente è libera. Altrimenti, la pagina è assegnata ad uno o più processi oppure è stata usata dal kernel.</li><li><code>private</code>: quando la pagina è libera (utilizzata dal buddy system)</li><li><code>lru</code>: puntatore alla double linked list LRU (<em>Last Recently Used</em>) (utilizzata dal buddy system)</li></ul><h3 id=zone-descriptor>Zone descriptor</h3><p>Il kernel partiziona la memoria fisica in tre zone diverse:</p><ul><li><code>ZONE_DMA</code> (&lt;16 MB): questa zona contiene le pagine che possono essere utilizzate dal DMA</li><li><code>ZONE_NORMAL</code> (16-896 MB): questa zona contiene le normali pagine mappate</li><li><code>ZONE_HIGHMEM</code> (>896 MB): questa zona contiene &ldquo;l&rsquo;high memory&rdquo; che sono le pagine non permanentemente mappata nello spazio di indirizzamento del kernel</li></ul><p>Ogni zona di memoria ha il suo descrittore.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>zone</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>free_pages</span><span class=p>;</span> <span class=c1>// Number of free pages in the zone.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>free_area_t</span> <span class=n>free_area</span><span class=p>[</span><span class=n>MAX_ORDER</span><span class=p>];</span> <span class=c1>// buddy blocks (see next)
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>page_t</span> <span class=o>*</span><span class=n>zone_mem_map</span><span class=p>;</span> <span class=c1>// pointer to first page descriptor
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>uint32_t</span> <span class=n>zone_start_pfn</span><span class=p>;</span> <span class=c1>// Index of the first page frame
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>size</span><span class=p>;</span> <span class=c1>// Total size of zone in pages
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>char</span> <span class=o>*</span><span class=n>name</span><span class=p>;</span> <span class=c1>// Name of the zone
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></div><h3 id=zoned-page-frame-allocator>Zoned page frame allocator</h3><p>Zoned page frame allocator è un sottosistema kernel che gestisce le richieste di allocazione e de-allocazione della memoria per un gruppo continuo di pagine.</p><p>L&rsquo;allocatore delle pagine fornisce le seguenti funzioni per richiedere o rilasciare frame di pagine:</p><ul><li><p><code>alloc_pages(zone, order)</code>:<br>Funzione utilizzata per richiedere 2^order page frame da una determinata zone. Ritorna la prima pagina page_t di un blocco di 2^order page frame contigue oppure ritorna NULL se l&rsquo;allocazione è fallita.</p></li><li><p><code>free_pages(page, order)</code>:<br>Funzione utilizzata per rilasciare 2^order pagine contigue da una determinata zona.</p></li></ul><p>N.B: Abitualmente quete funzioni non ricevono una zona come un argomento, ma hanno una flag Get Free Page (GFP) (<code>GFP_KERNEL</code>, <code>GFP_USER</code>, <code>GFP_DMA</code>).</p><h2 id=buddy-system>Buddy system</h2><p>Il buddy system è una strategia robusta ed efficiente per allocare gruppi di pagine frame contigue in potenze di 2. Tutte le pagine libere sono raggruppate in 11 liste di blocchi che contengono rispettivamente 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024 pagine contigue.</p><p>La più grande richiesta di 1024 page frame corrisponde ad 4MB di dati contigui dalla RAM. La richiesta più piccola corrisponde ad una sola pagina di dimensione di 4KB di RAM.</p><p>Guardiamo come l&rsquo;algoritmo funziona con un semplice esempio.</p><h3 id=stato-iniziale>Stato iniziale</h3><p>Array di Page_t che descrive lo stato di ogni frame:</p><table><thead><tr><th>Numero</th><th>_count</th><th>private</th></tr></thead><tbody><tr><td>7</td><td>-1</td><td>0</td></tr><tr><td>6</td><td>-1</td><td>0</td></tr><tr><td>5</td><td>-1</td><td>0</td></tr><tr><td>4</td><td>-1</td><td>0</td></tr><tr><td>3</td><td>-1</td><td>0</td></tr><tr><td>2</td><td>-1</td><td>0</td></tr><tr><td>1</td><td>-1</td><td>0</td></tr><tr><td>0</td><td>-1</td><td>3</td></tr></tbody></table><p>TODO: Esempio</p><h3 id=algoritmo-alloc_pages>Algoritmo alloc_pages</h3><h4 id=soddisfacimento-della-richiesta>Soddisfacimento della richiesta</h4><p>Algoritmo 1 per cercare un blocco sufficientemente grande per soddisfare la richiesta.</p><p><strong>Richiede</strong>: <code>free_area</code> array <code>f</code>, richiesta <code>ro</code></p><p><strong>Output</strong>: blocco oppure NULL</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=n>fo</span> <span class=o>=</span> <span class=n>ro</span>
</span></span><span class=line><span class=cl>	<span class=k>while</span> <span class=n>fo</span> <span class=o>&lt;</span> <span class=no>MAX</span> <span class=no>ORDER</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=o>!</span><span class=n>empty</span><span class=p>(</span><span class=n>f</span><span class=o>[</span><span class=n>fo</span><span class=o>]</span><span class=p>)</span> <span class=k>then</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=n>fo</span>
</span></span><span class=line><span class=cl>		<span class=k>end</span> <span class=k>if</span>
</span></span><span class=line><span class=cl>		<span class=n>fo</span> <span class=o>=</span> <span class=n>fo</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>	<span class=k>end</span> <span class=k>while</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=no>NULL</span></span></span></code></pre></div><h4 id=rimuovere-un-blocco-di-pagine-libere>Rimuovere un blocco di pagine libere</h4><p>Algoritmo 2 per rimuovere un blocco di pagine libere.</p><p><strong>Richiede</strong>: array f di free_area, il blocco trovato</p><p><strong>Output</strong>: blocco di pagine</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=n>block</span> <span class=o>=</span> <span class=n>getFirstBlock</span><span class=p>(</span><span class=n>f</span><span class=o>[</span><span class=n>fo</span><span class=o>]</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>removeBlock</span><span class=p>(</span><span class=n>f</span><span class=o>[</span><span class=n>fo</span><span class=o>]</span><span class=p>,</span> <span class=n>block</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=n>block</span></span></span></code></pre></div><h4 id=splitting-del-blocco>Splitting del blocco</h4><p>L&rsquo;algoritmo 3 serve per dividere un blocco sufficientemente grande per la richiesta. La funzione <em>splitRight</em> prende in input un blocco e ritorna la metà di destra. La funzione <em>splitLeft</em> prende in input un blocco e ritorna la metà di sinistra.</p><p><strong>Richiede</strong>: l&rsquo;array f di free_area, la richiesta ro, l&rsquo;ordine fo e il blocco block</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=k>while</span> <span class=n>fo</span> <span class=o>&gt;</span> <span class=n>ro</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>	<span class=n>free</span> <span class=n>block</span> <span class=o>=</span> <span class=n>splitRight</span><span class=p>(</span><span class=n>block</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>fo</span> <span class=o>=</span> <span class=n>fo</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>	<span class=n>addBlock</span><span class=p>(</span><span class=n>f</span><span class=o>[</span><span class=n>fo</span><span class=o>]</span><span class=p>,</span> <span class=n>free</span> <span class=n>block</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>block</span> <span class=o>=</span> <span class=n>splitLeft</span><span class=p>(</span><span class=n>block</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>end</span> <span class=k>while</span>	</span></span></code></pre></div><p>TODO: Esempi</p><h3 id=free_pages>free_pages</h3><h4 id=ricerca-di-un-blocco-sufficientemente-grande-a-soddisfare-la-richiesta>Ricerca di un blocco sufficientemente grande a soddisfare la richiesta</h4><p><strong>Input</strong>: free_area f, blocco b, ordine o</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=k>while</span> <span class=n>o</span> <span class=o>&lt;</span> <span class=no>MAX</span> <span class=no>ORDER</span> <span class=o>-</span> <span class=mi>1</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>	<span class=n>buddy</span> <span class=o>=</span> <span class=n>getBuddy</span><span class=p>(</span><span class=n>b</span><span class=p>,</span> <span class=n>o</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=o>!</span><span class=n>free</span><span class=p>(</span><span class=n>buddy</span><span class=p>)</span> <span class=o>|</span> <span class=n>order</span><span class=p>(</span><span class=n>buddy</span><span class=p>)</span> <span class=o>!=</span> <span class=n>o</span> <span class=k>then</span>
</span></span><span class=line><span class=cl>		<span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>end</span> <span class=k>if</span>
</span></span><span class=line><span class=cl>	<span class=n>removeBlock</span><span class=p>(</span><span class=n>f</span><span class=o>[</span><span class=n>o</span><span class=o>]</span><span class=p>,</span> <span class=n>buddy</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>buddy</span> <span class=o>&lt;</span> <span class=n>b</span> <span class=k>then</span>
</span></span><span class=line><span class=cl>		<span class=n>b</span> <span class=o>=</span> <span class=n>buddy</span>
</span></span><span class=line><span class=cl>	<span class=k>end</span> <span class=k>if</span>
</span></span><span class=line><span class=cl>	<span class=n>o</span> <span class=o>=</span> <span class=n>o</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=k>end</span> <span class=k>while</span>
</span></span><span class=line><span class=cl><span class=n>addBlock</span><span class=p>(</span><span class=n>f</span><span class=o>[</span><span class=n>o</span><span class=o>]</span><span class=p>,</span> <span class=n>b</span><span class=p>)</span></span></span></code></pre></div><h2 id=gestione-della-memoria-virtuale>Gestione della memoria virtuale</h2><p>Il kernel applica la memoria virtuale per mappare gli indirizzi virtuali agli indirizzi fisici.</p><p>Vantaggi:</p><ul><li>La RAM può essere virtualmente suddivisa in spazio kernel o spazio utente;</li><li>ogni singola pagina può avere differenti permessi;</li><li>ogni processo ha il suo mapping di memoria;</li><li>un processo può accedere solo ad un determinato sottoinsieme di memoria fisica disponibile;</li><li>un processo può essere rilocabile;</li></ul><p>Come un processore tradure un indirizzo virtuale in uno fisico?</p><h3 id=memory-management-unit>Memory Management Unit</h3><p>La Memory Management Unit è il componente hardware che mappa gli indirizzi virtuali in indirizzi fisici. Vantaggi: la mappatura viene eseguita in hardware, quindi nessuna penalizzazione delle prestazioni, stesse istruzioni della CPU utilizzate per accedere alla RAM e all&rsquo;hardware mappato.</p><p>Come fa il kernel a tenere traccia della mappatura tra la pagina virtuale di un processo pagina virtuale di un processo al suo corrispondente page frame? Per ogni pagina virtuale del processo, il Kernel mantiene una corrispondente Page Table Entry (PTE).</p><ul><li>P se impostato, la pagina è in memoria fisica.</li><li>R/W se impostato, la pagina è in modalità lettura/scrittura.</li><li>U/S se impostato, la pagina è accessibile a tutti.</li><li>A se impostato, la pagina è stata acceduta.</li><li>D se impostato, la pagina è sporca.
Come fa il kernel a tenere traccia della mappatura delle pagine virtuali di tutti i processi pagine virtuali di tutti i processi ai loro corrispondenti page frame?</li></ul><p>Per ogni processo, il Kernel organizza i suoi PTE in una struttura dati gerarchica a due livelli struttura dati a due livelli:</p><p><strong>Primo livello</strong>: una Page Directory che raccoglie 1024 indirizzi di Page Table.<br><strong>Secondo livello</strong>: una Page Table raccoglie 1024 voci di tabella di pagina.</p><h3 id=memory-descriptor>Memory descriptor</h3><p>Il descrittore di memoria è la struttura dati del Kernel usata per descrivere:</p><ul><li>tabelle di pagina: Il processo usa indirizzi virtuali. Le tabelle di pagina permettono all&rsquo;unità di gestione della memoria di trasformare un indirizzo logico in un indirizzo fisico.</li><li>regioni di memoria: Il layout di memoria di un processo è diviso in regioni (.text, .data, ecc.), ognuna delle quali ha permessi di utilizzo e dimensioni.</li></ul><p>N.B.: Le regioni di un processo sono chiamate segmenti nella terminologia di Linux! Non confondete le regioni del processo con la segmentazione della memoria. Nelle prossime diapositive, parleremo delle regioni .text, .data come segmenti!</p><p>La struttura <code>mm_struct</code> mm (chiamato descrittore di memoria) di una task struct raccoglie i seguenti attributi:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>mm_struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>start_stack</span><span class=p>;</span> <span class=c1>// start address of stack segment
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>mmap_base</span><span class=p>;</span> <span class=c1>// start address of memory mapping
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>brk</span><span class=p>;</span> <span class=c1>// end address of heap segment
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>start_brk</span><span class=p>;</span> <span class=c1>// start address of heap segment
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>end_data</span><span class=p>;</span> <span class=c1>// end address of data segment
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>start_data</span><span class=p>;</span> <span class=c1>// start address of data segment
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>end_code</span><span class=p>;</span> <span class=c1>// end address of code segment
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>start_code</span><span class=p>;</span> <span class=c1>// start address of code segment
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>struct</span> <span class=n>vm_area_struct</span> <span class=o>*</span><span class=n>mmap</span><span class=p>;</span> <span class=c1>// list of memory region descr.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>pgd_t</span> <span class=o>*</span><span class=n>pgd</span><span class=p>;</span> <span class=c1>// pointer to page directory
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></div><h3 id=segment-descriptor>Segment descriptor</h3><p>Il campo vm_area_struct <code>mmap</code> di un descrittore di memoria è la struttura di dati utilizzata per rappresentare un&rsquo;area di memoria virtuale contigua all&rsquo;interno di un segmento di un processo.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>vm_area_struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>vm_start</span><span class=p>;</span> <span class=c1>// start address of segment
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>vm_end</span><span class=p>;</span> <span class=c1>// end address of segment
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>flag</span><span class=p>;</span> <span class=c1>// access permissions
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>struct</span> <span class=n>file</span> <span class=o>*</span><span class=n>vm_file</span><span class=p>;</span> <span class=c1>// pointer to mapped file
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>struct</span> <span class=n>vm_area_struct</span> <span class=o>*</span><span class=n>next</span><span class=p>;</span> <span class=c1>// next region of process
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></div><p>Perché abbiamo di nuovo l&rsquo;indirizzo iniziale e finale qui?
Consiglio: una pagina (4KB) è l&rsquo;unità di base della memoria. Quando un processo chiede di memoria, riceve le pagine dal Kernel.</p><p>Ogni area di memoria virtuale identifica un intervallo lineare di indirizzi di pagine logiche contigue e ha sempre una dimensione multipla della dimensione della pagina. Il descrittore di memoria riporta l&rsquo;ultimo byte utilizzato all&rsquo;interno del segmento di ogni processo segmento.</p><p>TODO: Slide sul segmentation fault e rappresentazione memoria</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>size_t</span> <span class=n>size</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=o>*</span> <span class=mi>1536</span><span class=p>;</span> <span class=c1>// 6KB
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=o>*</span><span class=n>i</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=p>)</span> <span class=n>malloc</span> <span class=p>(</span><span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=mi>1536</span><span class=p>;</span> <span class=o>++</span><span class=n>j</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>i</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>j</span><span class=p>;</span></span></span></code></pre></div><p>Il flag di campo della struct <code>vm_area</code> riporta i dettagli su tutte le pagine del segmento di un processo: cosa contengono, quali diritti ha il processo per accedere ad ogni pagina, come può crescere il segmento, ecc.</p><table><thead><tr><th>Nome</th><th>Descrizione</th></tr></thead><tbody><tr><td><code>VM_READ</code></td><td>Le pagine possono essere lette</td></tr><tr><td><code>VM_WRITE</code></td><td>Le pagine possono essere scritte</td></tr><tr><td><code>VM_EXEC</code></td><td>Le pagine possono essere eseguite</td></tr><tr><td><code>VM_SHM</code></td><td>La regione è usata per la memoria condivisa di IPC</td></tr><tr><td><code>VM_LOCKED</code></td><td>Le pagine sono bloccate e non possono essere scambiate</td></tr><tr><td><code>VM_GROWSDOWN</code></td><td>La regione può espandersi verso indirizzi inferiori</td></tr><tr><td><code>VM_GROWSUP</code></td><td>La regione può espandersi verso indirizzi più alti</td></tr></tbody></table><footer><p>Contenuto basato sulle slide del corso di Sistemi Operativi A.A Laboratorio 2021-2022 UniVR. Copyright degli autori delle slide originali.
<a href=https://github.com/seekbytes/oslab/edit/main/content/lezioni/8_MentOS_buddy_system.md>Modifica questa pagina</a></p></footer></div></body></html>