<!doctype html><html lang=it><head><meta charset=utf-8><meta name=author content="SeekBytes"><meta name=viewport content="width=device-width,initial-scale=1"><title>Lezione 2 - Processi</title><link href=/css/style.css rel=stylesheet><link rel=stylesheet type=text/css href=/css/syntax.css><link href=/css/print.css rel=stylesheet media=print><meta name=description content="Interazioni tra processi: fork e execl, PID e File Descriptor Table."></head><body class=flex><div class=navbar-lat><div class=links><h2>Indice</h2><nav id=TableOfContents><ul><li><a href=#ripasso>Ripasso</a></li><li><a href=#attributi-di-un-processo>Attributi di un processo</a><ul><li><a href=#identificativo-di-un-processo-pid>Identificativo di un processo (PID)</a><ul><li><a href=#getpid>getpid</a></li></ul></li><li><a href=#real-user-id-e-effective-user-id>Real User ID e Effective User ID</a><ul><li><a href=#getuid-getgid-geteuid-getegid>getuid, getgid, geteuid, getegid</a></li></ul></li></ul></li><li><a href=#environ>Environ</a><ul><li><ul><li><a href=#getenv>getenv</a></li><li><a href=#setenv>setenv</a></li><li><a href=#unsetenv>unsetenv</a></li></ul></li></ul></li><li><a href=#directory-del-processo>Directory del processo</a><ul><li><a href=#getcwd>getcwd</a></li><li><a href=#chdir>chdir</a></li><li><a href=#fchdir>fchdir</a></li></ul></li><li><a href=#file-descriptor-table>File Descriptor Table</a><ul><li><a href=#int-dupint-oldfd>int dup(int oldfd)</a></li></ul></li><li><a href=#operazioni-con-i-processi>Operazioni con i processi</a><ul><li><a href=#terminazione-dei-processi>Terminazione dei processi</a><ul><li><a href=#void-_exitint-status>void _exit(int status)</a></li><li><a href=#void-exitint-status>void exit(int status)</a></li><li><a href=#int-atexitvoid-funcvoid>int atexit(void (*func)(void));</a></li></ul></li><li><a href=#creazione-dei-processi>Creazione dei processi</a><ul><li><a href=#pid_t-forkvoid>pid_t fork(void)</a></li><li><a href=#pid_t-getppidvoid>pid_t getppid(void);</a></li></ul></li><li><a href=#controllo-dei-processi-figlio>Controllo dei processi figlio</a><ul><li><a href=#pid_t-waitint-status>pid_t wait(int *status)</a></li><li><a href=#pid_t-waitpidpid_t-pid-int-status-int-options>pid_t waitpid(pid_t pid, int *status, int options);</a></li></ul></li><li><a href=#esecuzione-di-programmi-exec>Esecuzione di programmi (exec)</a><ul><li><a href=#funzioni-della-libreria-exec>Funzioni della libreria exec</a></li></ul></li><li><a href=#osservazioni-finali-sulle-funzioni-della-libreria-exec>Osservazioni finali sulle funzioni della libreria exec</a></li></ul></li></ul></nav><h3>Contenuti</h3><ul><li><a href=http://seekbytes.github.io/oslab/lezioni/0-sistemi-operativi-laboratorio/>Lezione 0 - Introduzione a Sistemi Operativi Laboratorio</a></li><li><a href=http://seekbytes.github.io/oslab/lezioni/1-a-concetti-fondamentali/>Lezione 1.A - Concetti fondamentali: Processi e Programmi</a></li><li><a href=http://seekbytes.github.io/oslab/lezioni/1-b-file-system/>Lezione 1.B - Concetti fondamentali: File System</a></li><li><a href=http://seekbytes.github.io/oslab/lezioni/2-processi/>Lezione 2 - Processi</a></li><li><a href=http://seekbytes.github.io/oslab/lezioni/3-mentos/>Lezione 3.A - Fondamentali di MentOS</a></li><li><a href=http://seekbytes.github.io/oslab/lezioni/3-b-mentos-scheduling/>Lezione 3.B - MentOS Scheduling</a></li><li><a href=http://seekbytes.github.io/oslab/lezioni/4-a-semafori-ipc/>Lezione 4.A - IPC e Semafori</a></li><li><a href=http://seekbytes.github.io/oslab/lezioni/4-b-segnali-ipc/>Lezione 4.B - IPC e Segnali</a></li><li><a href=http://seekbytes.github.io/oslab/lezioni/5-memoria-condivisa-coda-di-messaggi/>Lezione 5 - Memoria condivisa e coda di messaggi</a></li><li><a href=http://seekbytes.github.io/oslab/lezioni/6-pipe-fifo/>Lezione 6 - Pipe e FIFO</a></li></ul><a href=../>Sezione principale</a></div></div><div class=content><a href=/>Ritorna indietro</a><h1>Lezione 2 - Processi</h1><p class=details>Pubblicato il 11/8/21 da SeekBytes – 3256 parole</p><h2 id=ripasso>Ripasso</h2><div class=definition><h3>Definizione di Processo</h3>Un processo è un&rsquo;istanza di un programma in esecuzione.</div><p>Dal punto di vista del kernel, un processo consiste di:</p><ul><li>memoria user-space (nello spazio utente) contenente il codice del programma,</li><li>le variabili utilizzate nel codice, e</li><li>una serie di strutture dati del kernel che mantengono informazioni riguardo lo stato del processo (esempio: tabelle delle pagine, tabella dei file aperti, segnali da inviare, l&rsquo;utilizzo delle risorse del processo e i limiti..)</li></ul><h2 id=attributi-di-un-processo>Attributi di un processo</h2><h3 id=identificativo-di-un-processo-pid>Identificativo di un processo (PID)</h3><h4 id=getpid>getpid</h4><p>La chiamata di sistema getpid restituisce l&rsquo;ID di processo del processo chiamante.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/types.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=n>pid_t</span> <span class=nf>getpid</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span></span></span></code></pre></div><p>Il tipo di dati <code>pid_t</code> usato per il valore di ritorno di getpid è un tipo intero allo scopo di memorizzare gli ID dei processi.
Con l&rsquo;eccezione di alcuni processi di sistema come <code>init</code> (process ID 1), non c&rsquo;è una relazione fissa tra un programma e l&rsquo;ID del processo processo che viene creato per eseguire quel programma.</p><details><summary><b>Esempio</b></summary>
<code>user@localhost[~]$ ps auxf</code></details><p>NOTA BENE: la chiamata a getpid funziona SEMPRE!!!</p><h3 id=real-user-id-e-effective-user-id>Real User ID e Effective User ID</h3><h4 id=getuid-getgid-geteuid-getegid>getuid, getgid, geteuid, getegid</h4><p>Le chiamate di sistema <code>getuid</code> e <code>getgid</code> restituiscono, rispettivamente, l&rsquo;ID utente reale e l&rsquo;ID del gruppo reale del processo chiamante. Le chiamate di sistema <code>geteuid</code> e <code>getegid</code> eseguono i compiti corrispondenti per gli ID effettivi.</p><p>NOTA BENE: funzionano sempre.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/types.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=n>uid_t</span> <span class=nf>getuid</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span> <span class=c1>// Real user ID
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>uid_t</span> <span class=nf>geteuid</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span> <span class=c1>// Effective user ID
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>gid_t</span> <span class=nf>getgid</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span> <span class=c1>// Real group ID
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>gid_t</span> <span class=nf>getegid</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span> <span class=c1>// Effective group ID
</span></span></span></code></pre></div><ul><li>L&rsquo;ID utente reale e l&rsquo;ID gruppo identificano l&rsquo;utente e il gruppo a cui il processo appartiene,</li><li>l&rsquo;ID utente effettivo e l&rsquo;ID gruppo sono usati per determinare i permessi concessi ad un processo quando cerca di eseguire delle operazioni.</li></ul><details><summary><b>Esempio getuid, getgid, geteuid, getegid</b></summary><p>Questo è il contenuto di un file program.c</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/types.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>main</span> <span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=err>\</span><span class=o>*</span><span class=n>argv</span><span class=p>[])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>printf</span><span class=p>(</span><span class=s>&#34;PID: %d, user-ID: real %d, effective %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>getpid</span><span class=p>(),</span> <span class=n>getuid</span><span class=p>(),</span> <span class=n>geteuid</span><span class=p>());</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>user@localhost<span class=o>[</span>~<span class=o>]</span>$ gcc -o program program.c
</span></span><span class=line><span class=cl>user@localhost<span class=o>[</span>~<span class=o>]</span>$ ls -l program
</span></span><span class=line><span class=cl>-r-xr-xr-x <span class=m>1</span> Professor Professor <span class=m>8712</span> Jan <span class=m>16</span> 16:27 program
</span></span><span class=line><span class=cl>user@localhost<span class=o>[</span>~<span class=o>]</span>$ ./program
</span></span><span class=line><span class=cl>PID: 1234, user-ID: real 1000, effective <span class=m>1000</span>
</span></span><span class=line><span class=cl>user@localhost<span class=o>[</span>~<span class=o>]</span>$ sudo ./program
</span></span><span class=line><span class=cl>PID: 1423, user-ID: real 0, effective <span class=m>0</span>
</span></span><span class=line><span class=cl>user@localhost<span class=o>[</span>~<span class=o>]</span>$ sudo chmod u+s program
</span></span><span class=line><span class=cl>user@localhost<span class=o>[</span>~<span class=o>]</span>$ ls -l program
</span></span><span class=line><span class=cl>-r-sr-xr-x <span class=m>1</span> root Professor <span class=m>8712</span> Jan <span class=m>16</span> 16:27 program
</span></span><span class=line><span class=cl>user@localhost<span class=o>[</span>~<span class=o>]</span>$ ./program
</span></span><span class=line><span class=cl>PID: 4321, user-ID: real 1000, effective <span class=m>0</span></span></span></code></pre></div></details><p>Tieni a mente: se lo <strong>S</strong>ticky bit non è settato, allora i permessi dell&rsquo;utente sono garantiti all&rsquo;eseguibile per fare operazioni. Altrimenti se è impostato, allora i permessi del <strong>proprietario</strong> sono garantiti all&rsquo;eseguibile.</p><h2 id=environ>Environ</h2><p>Ogni processo ha un array associato di stringhe chiamato lista d&rsquo;ambiente, o semplicemente ambiente. Ognuna di queste stringhe è una definizione della forma nome = valore. Quando un nuovo processo viene creato, eredita una copia dell&rsquo;ambiente del suo genitore.</p><p>La struttura dell&rsquo;elenco degli ambienti è la seguente:</p><p>All&rsquo;interno di un programma C, si può accedere all&rsquo;elenco degli ambienti in due modi:</p><ul><li><p>usando la variabile globale <code>char **environ</code>. Originariamente era usata specificamente nei sistemi POSIX, ora questa tecnica è ampiamente usata e supportata da molti sistemi.</p></li><li><p>oppure si può anche ricevere l&rsquo;ambiente corrente come terzo argomento della funzione principale. Questa tecnica è riconosciuta come standard C, ma non è supportata da tutti i sistemi operativi.</p></li></ul><details><summary><b>Esempio prima tecnica</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// Global variable pointing to the enviroment of the process.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>extern</span> <span class=kt>char</span> <span class=o>**</span><span class=n>environ</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>(</span><span class=kt>char</span> <span class=o>**</span><span class=n>it</span> <span class=o>=</span> <span class=n>environ</span><span class=p>;</span> <span class=p>(</span><span class=o>*</span><span class=n>it</span><span class=p>)</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>;</span> <span class=o>++</span><span class=n>it</span><span class=p>)</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>		<span class=n>printf</span><span class=p>(</span><span class=s>&#34;--&gt; %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>*</span><span class=n>it</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>user@localhost<span class=o>[</span>~<span class=o>]</span>$ ./program --&gt; <span class=nv>$HOME</span><span class=o>=</span>/home/Professor
</span></span><span class=line><span class=cl>--&gt; <span class=nv>$PWD</span><span class=o>=</span>/tmp
</span></span><span class=line><span class=cl>--&gt; <span class=nv>$USER</span><span class=o>=</span>Professor</span></span></code></pre></div></details><details><summary><b>Esempio seconda tecnica</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[],</span> <span class=kt>char</span><span class=o>*</span> <span class=n>env</span><span class=p>[])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>(</span><span class=kt>char</span> <span class=o>**</span><span class=n>it</span> <span class=o>=</span> <span class=n>env</span><span class=p>;</span> <span class=p>(</span><span class=o>*</span><span class=n>it</span><span class=p>)</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>;</span> <span class=o>++</span><span class=n>it</span><span class=p>)</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>		<span class=n>printf</span><span class=p>(</span><span class=s>&#34;--&gt; %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>*</span><span class=n>it</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>user@localhost<span class=o>[</span>~<span class=o>]</span>$ ./program --&gt; <span class=nv>$HOME</span><span class=o>=</span>/home/Professor
</span></span><span class=line><span class=cl>--&gt; <span class=nv>$PWD</span><span class=o>=</span>/tmp
</span></span><span class=line><span class=cl>--&gt; <span class=nv>$USER</span><span class=o>=</span>Professor</span></span></code></pre></div></details><h4 id=getenv>getenv</h4><p>Dato il nome di variabile <code>name</code>, getenv ritorna un puntatore al valore della stringa accessibile tramite <code>name</code> oppure NULL se non esiste la variabile d&rsquo;ambiente.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// Returns pointer to (value) string, or NULL if no such variable exists
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>char</span> <span class=o>*</span><span class=nf>getenv</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>name</span><span class=p>);</span>	
</span></span></code></pre></div><h4 id=setenv>setenv</h4><p>Setenv aggiunge name=value all&rsquo;ambiente, a meno che non esista già una variabile identificata da name e overwrite abbia il valore 0. Se overwrite è diverso da zero, l&rsquo;ambiente viene sempre cambiato. Ritorna 0 se ha successo, oppure -1 errore.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>setenv</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>name</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>value</span><span class=p>,</span> <span class=kt>int</span> <span class=n>overwrite</span><span class=p>);</span></span></span></code></pre></div><h4 id=unsetenv>unsetenv</h4><p>unsetenv rimuove la variabile identificata dal nome dall&rsquo;ambiente.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>unsetenv</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>name</span><span class=p>);</span></span></span></code></pre></div><h2 id=directory-del-processo>Directory del processo</h2><p>Un processo può recuperare la sua directory di lavoro corrente usando <code>getcwd</code>.</p><h3 id=getcwd>getcwd</h3><p>Quando l&rsquo;invocazione ha successo, getcwd restituisce un puntatore a cwdbuf come risultato della sua funzione. Se il percorso della directory di lavoro corrente supera i byte di dimensione, allora getcwd restituisce NULL.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// Returns cwdbuf on success, or NULL on error.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>char</span> <span class=o>*</span><span class=nf>getcwd</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>cwdbuf</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>size</span><span class=p>);</span></span></span></code></pre></div><p>Il chiamante deve allocare il buffer cwdbuf in modo che abbia una lunghezza minima di byte di dimensione. (Normalmente, dimensioneremmo cwdbuf usando la costante PATH MAX).</p><h3 id=chdir>chdir</h3><p>La chiamata di sistema chdir cambia la directory di lavoro corrente del processo chiamante nel percorso relativo o assoluto specificato in pathname.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// Returns 0 on success, or -1 on error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>chdir</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>pathname</span><span class=p>);</span></span></span></code></pre></div><h3 id=fchdir>fchdir</h3><p>La chiamata di sistema fchdir fa la stessa cosa di chdir, eccetto che la directory è specificata tramite un descrittore di file precedentemente ottenuto aprendo la directory con open.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define _BSD_SOURCE
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>	
</span></span><span class=line><span class=cl><span class=c1>// Returns 0 on success, or -1 on error.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>fchdir</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>);</span></span></span></code></pre></div><details><summary><b>Esempio con la fchdir</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=n>PATH_MAX</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=c1>// Open the current working directory
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>fd</span> <span class=o>=</span> <span class=n>open</span><span class=p>(</span><span class=s>&#34;.&#34;</span><span class=p>,</span> <span class=n>O_RDONLY</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>getcwd</span><span class=p>(</span><span class=n>buf</span><span class=p>,</span> <span class=n>PATH_MAX</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>printf</span><span class=p>(</span><span class=s>&#34;1) Current dir:</span><span class=se>\n\t</span><span class=s>%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>buf</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// Move the process into /tmp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>chdir</span><span class=p>(</span><span class=s>&#34;/tmp&#34;</span><span class=p>);</span> <span class=n>getcwd</span><span class=p>(</span><span class=n>buf</span><span class=p>,</span> <span class=n>PATH_MAX</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>printf</span><span class=p>(</span><span class=s>&#34;2) Current dir:</span><span class=se>\n\t</span><span class=s>%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>buf</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// Move the process back into the initial directory
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>fchdir</span><span class=p>(</span><span class=n>fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>getcwd</span><span class=p>(</span><span class=n>buf</span><span class=p>,</span> <span class=n>PATH_MAX</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>printf</span><span class=p>(</span><span class=s>&#34;3) Current dir:</span><span class=se>\n\t</span><span class=s>%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>buf</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// Close the file descriptor
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>close</span><span class=p>(</span><span class=n>fd</span><span class=p>);</span></span></span></code></pre></div><p>output:</p><pre tabindex=0><code>1) Current dir:
/home/Professor
2) Current dir:
/tmp
3) Current dir:
/home/Professor
</code></pre></details><h2 id=file-descriptor-table>File Descriptor Table</h2><p>Ogni processo ha una file descriptor table associata. Ogni voce rappresenta una risorsa di input/output (es. file, pipe, socket) usata dal processo.</p><p>La directory <code>/proc/&lt;PID>/fd</code> contiene un collegamento simbolico per ogni voce della tabella dei descrittori di file di un processo. La cartella <code>/proc/</code> è uno pseudo-file system che non contiene file reali, ma alcune informazioni di sistema a tempo di esecuzione.</p><p>Un processo creato ha sempre tre descrittori di file (stdin, stdout, stderr).</p><details><summary><b>Vedere i file descriptor associati ad un processo</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>user@localhost<span class=o>[</span>~<span class=o>]</span>$ sleep <span class=m>30</span> <span class=p>&amp;</span>
</span></span><span class=line><span class=cl><span class=o>[</span>1<span class=o>]</span> <span class=m>1344</span>
</span></span><span class=line><span class=cl>user@localhost<span class=o>[</span>~<span class=o>]</span>$ ls -l /proc/1344/fd
</span></span><span class=line><span class=cl>totale <span class=m>0</span>
</span></span><span class=line><span class=cl>lrwx------ <span class=m>1</span> Professor Professor <span class=m>0</span> Gen <span class=m>18</span> 12:35 <span class=m>0</span> -&gt; /dev/pts/0
</span></span><span class=line><span class=cl>lrwx------ <span class=m>1</span> Professor Professor <span class=m>0</span> Gen <span class=m>18</span> 12:35 <span class=m>1</span> -&gt; /dev/pts/0 
</span></span><span class=line><span class=cl>lrwx------ <span class=m>1</span> Professor Professor <span class=m>0</span> Gen <span class=m>18</span> 12:35 <span class=m>2</span> -&gt; /dev/pts/0</span></span></code></pre></div></details><details><summary><b>Visualizzare le voci del descrittore di file di un processo</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=n>PATH_MAX</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=c1>// Replace %i with PID, and store the resulting string in buf.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>snprintf</span><span class=p>(</span><span class=n>buf</span><span class=p>,</span> <span class=n>PATH_MAX</span><span class=p>,</span> <span class=s>&#34;/proc/%i/fd/&#34;</span><span class=p>,</span> <span class=n>getpid</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=n>DIR</span> <span class=o>*</span><span class=n>dir</span> <span class=o>=</span> <span class=n>opendir</span><span class=p>(</span><span class=n>buf</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>dirent</span> <span class=o>*</span><span class=n>dp</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=p>((</span><span class=n>dp</span> <span class=o>=</span> <span class=n>readdir</span><span class=p>(</span><span class=n>dir</span><span class=p>))</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>((</span><span class=n>strcmp</span><span class=p>(</span><span class=n>dp</span><span class=o>-&gt;</span><span class=n>d_name</span><span class=p>,</span><span class=s>&#34;.&#34;</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>strcmp</span><span class=p>(</span><span class=n>dp</span><span class=o>-&gt;</span><span class=n>d_name</span><span class=p>,</span><span class=s>&#34;..&#34;</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>))</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>		<span class=n>printf</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>Entry: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>dp</span><span class=o>-&gt;</span><span class=n>d_name</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>closedir</span><span class=p>(</span><span class=n>dir</span><span class=p>);</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>user@localhost<span class=o>[</span>~<span class=o>]</span>$ ./program
</span></span><span class=line><span class=cl>Entry: <span class=m>0</span> // link to stdin
</span></span><span class=line><span class=cl>Entry: <span class=m>1</span> // link to stdout
</span></span><span class=line><span class=cl>Entry: <span class=m>2</span> // link to stderr
</span></span><span class=line><span class=cl>Entry: <span class=m>3</span> // link to /proc/&lt;PID&gt;/fd directory</span></span></code></pre></div></details><div class=important><h3>Importante!</h3>Ad una nuova voce nella file descriptor table viene sempre assegnato l&rsquo;indice più basso disponibile. Guarda l&rsquo;esempio sotto.</div><details><summary><b>Reindirizzare il flusso di output standard di un processo a un file chiamato myfile</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// We close STDOUT which has FD 1. The remaining file descriptors have // index 0 (stdin) and 2 (stderr).
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>close</span><span class=p>(</span><span class=n>STDOUT_FILENO</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// We open a new file, to which will be assigned FD 1 automatically
</span></span></span><span class=line><span class=cl><span class=c1>// because it is the lowest available index in the table.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>fd</span> <span class=o>=</span> <span class=n>open</span><span class=p>(</span><span class=s>&#34;myfile&#34;</span><span class=p>,</span> <span class=n>O_TRUNC</span> <span class=o>|</span> <span class=n>O_CREAT</span> <span class=o>|</span> <span class=n>O_WRONLY</span><span class=p>,</span> <span class=n>S_IRUSR</span> <span class=o>|</span> <span class=n>S_IWUSR</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// Printf uses the FD 1, thus, it will print on the file.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>printf</span><span class=p>(</span><span class=s>&#34;ciao</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span></span></span></code></pre></div>Nessuna stringa sarà visualizzata sul terminale, poiché il flusso stdout è chiuso. Tuttavia, tutte le stringhe stampate da printf saranno riportate in myfile.</details><h3 id=int-dupint-oldfd>int dup(int oldfd)</h3><p>La chiamata di sistema dup prende un descrittore di file aperto e restituisce un nuovo descrittore che si riferisce alla stessa descrizione del file aperto. Il nuovo descrittore è garantito essere il più basso descrittore di file inutilizzato.</p><details><summary><b>Esempio con dup</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// FDT: [0, 1, 2] -&gt; [0, 2]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>close</span><span class=p>(</span><span class=n>STDOUT_FILENO</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// FDT: [0, 2] -&gt; [0]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>close</span><span class=p>(</span><span class=n>STDERR_FILENO</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// FDT: [0] -&gt; [0, 1]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>fd</span> <span class=o>=</span> <span class=n>open</span><span class=p>(</span><span class=s>&#34;myfile&#34;</span><span class=p>,</span> <span class=n>O_TRUNC</span> <span class=o>|</span> <span class=n>O_CREAT</span> <span class=o>|</span> <span class=n>O_WRONLY</span><span class=p>,</span> <span class=n>S_IRUSR</span> <span class=o>|</span> <span class=n>S_IWUSR</span><span class=p>);</span> <span class=c1>// FDT: [0, 1] -&gt; [0, 1, 2]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>dup</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// FDT: [0: STDIN, 1: myfile, 2: myfile]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>printf</span><span class=p>(</span><span class=s>&#34;Have a good &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>fflush</span><span class=p>(</span><span class=n>stdout</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;day!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl> user@localhost<span class=o>[</span>~<span class=o>]</span>$ cat myfile Have a good day!</span></span></code></pre></div></details><h2 id=operazioni-con-i-processi>Operazioni con i processi</h2><h3 id=terminazione-dei-processi>Terminazione dei processi</h3><h4 id=void-_exitint-status>void _exit(int status)</h4><p>Il processo che chiama _exit() viene sempre terminato con successo.</p><p>Il primo byte dell&rsquo;argomento status definisce lo stato di terminazione del processo. Per convenzione, il valore zero indica che il processo si è concluso con successo, un valore di stato non nullo indica che il processo si è concluso senza successo.</p><h4 id=void-exitint-status>void exit(int status)</h4><p>I programmi generalmente chiamano exit() piuttosto che _exit().</p><p>La libreria C definisce le macro EXIT SUCCESS (0) e EXIT FAILURE (1)
Le seguenti azioni sono eseguite dal metodo exit():</p><ul><li>Chiamare i gestori di uscita (vedere le prossime diapositive).</li><li>Cancellare i buffer del flusso stdio.</li><li>Chiamare _exit(), utilizzando il valore fornito in status.</li></ul><p>Un gestore di uscita è una funzione che viene registrata durante la vita di un processo. Viene chiamata automaticamente durante la terminazione del processo tramite exit().</p><h4 id=int-atexitvoid-funcvoid>int atexit(void (*func)(void));</h4><p>La atexit() aggiunge il puntatore di funzione fornito <code>func</code> a una lista di funzioni che sono chiamate durante la terminazione del processo.</p><p><code>func</code> deve essere definita: non deve prendere argomenti e non deve restituire alcun valore. Se sono registrati più gestori di uscita, allora vengono chiamati nell&rsquo;ordine inverso di registrazione.</p><details><summary><b>Esempio con atexit</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt; #include &lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>void</span> <span class=nf>func1</span><span class=p>()</span> <span class=p>{</span> <span class=n>printf</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>Atexit function 1 called</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>func2</span><span class=p>()</span> <span class=p>{</span> <span class=n>printf</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>Atexit function 2 called</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span> <span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>atexit</span><span class=p>(</span><span class=n>func1</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>atexit</span><span class=p>(</span><span class=n>func2</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=n>_exit</span><span class=p>(</span><span class=n>EXIT_FAILURE</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>exit</span><span class=p>(</span><span class=n>EXIT_SUCCESS</span><span class=p>);</span> <span class=p>}</span></span></span></code></pre></div><p>Ecco l&rsquo;output del programma:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>user@localhost<span class=o>[</span>~<span class=o>]</span>$ ./exit_handlers
</span></span><span class=line><span class=cl>Atexit <span class=k>function</span> <span class=m>2</span> called
</span></span><span class=line><span class=cl>Atexit <span class=k>function</span> <span class=m>1</span> called</span></span></code></pre></div></details><p>Un altro modo in cui un processo può terminare è il ritorno da main():</p><ul><li><p>eseguire un ritorno esplicito n (return n) è equivalente a chiamare exit(n);</p></li><li><p>eseguire un ritorno implicito alla fine di main() è equivalente a chiamare exit(0) nello standard C99. Altrimenti, il comportamento del processo è indefinito.</p></li></ul><h3 id=creazione-dei-processi>Creazione dei processi</h3><h4 id=pid_t-forkvoid>pid_t fork(void)</h4><p>La chiamata di sistema fork() crea un nuovo processo, il figlio, che è un duplicato quasi esatto del processo chiamante, il genitore.</p><p>Dopo l&rsquo;esecuzione di una fork(), esistono due processi e, in ogni processo, l&rsquo;esecuzione continua dal punto in cui la fork() ritorna.</p><p>È indeterminato quale dei due processi sia il prossimo ad utilizzare la CPU.</p><p>Il processo figlio riceve i duplicati di tutti i descrittori di file del genitore e le relative memorie condivise (vedere le diapositive Filesystem e IPC).</p><p>Nel processo padre, ritorna il PID del processo figlio, altrimenti -1. Nel processo appena creato, la fork ritorna 0.</p><details><summary><b>Esempio con la fork</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>main</span> <span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>stack</span> <span class=o>=</span> <span class=mi>111</span><span class=p>;</span> <span class=n>pid_t</span> <span class=n>pid</span> <span class=o>=</span> <span class=n>fork</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=n>errExit</span><span class=p>(</span><span class=s>&#34;fork&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=c1>// --&gt;Both parent and child come here !!!&lt;--
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=n>stack</span> <span class=o>=</span> <span class=n>stack</span> <span class=o>*</span> <span class=mi>4</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>printf</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>%s stack %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=n>pid</span><span class=o>==</span><span class=mi>0</span><span class=p>)</span> <span class=o>?</span> <span class=s>&#34;(child )&#34;</span> <span class=o>:</span> <span class=s>&#34;(parent)&#34;</span><span class=p>,</span> <span class=n>stack</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Output del programma:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>user@localhost<span class=o>[</span>~<span class=o>]</span>$ ./example_fork <span class=o>(</span>parent<span class=o>)</span> stack <span class=m>111</span>
</span></span><span class=line><span class=cl><span class=o>(</span>child <span class=o>)</span> stack <span class=m>444</span>
</span></span><span class=line><span class=cl>user@localhost<span class=o>[</span>~<span class=o>]</span>$ ./example_fork <span class=o>(</span>child <span class=o>)</span> stack <span class=m>444</span>
</span></span><span class=line><span class=cl><span class=o>(</span>parent<span class=o>)</span> stack <span class=m>111</span></span></span></code></pre></div></details><p>L&rsquo;output del terminale mostra che:</p><ul><li>il processo figlio ottiene la propria copia delle variabili del genitore;</li><li>l&rsquo;esecuzione di entrambi i processi, genitore e figlio, continua dal punto in cui la fork() è ritornata;</li></ul><h4 id=pid_t-getppidvoid>pid_t getppid(void);</h4><p>Ogni processo ha un genitore, cioè il processo che lo ha creato.</p><p>L&rsquo;antenato di tutti i processi è il processo init (PID=1). Se un processo figlio diventa orfano perché il suo genitore termina, allora il figlio viene &ldquo;adottato&rdquo; dal processo init. Le successive chiamate a <code>getppid()</code> nel figlio restituiscono 1.</p><details><summary><b>Esempio codice</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>	<span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>	<span class=kt>int</span> <span class=nf>main</span> <span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>		<span class=n>pid_t</span> <span class=n>pid</span> <span class=o>=</span> <span class=n>fork</span><span class=p>();</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>			<span class=n>errExit</span><span class=p>(</span><span class=s>&#34;fork&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=n>printf</span><span class=p>(</span><span class=s>&#34;(child ) PID: %d PPID: %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>getpid</span><span class=p>(),</span> <span class=n>getppid</span><span class=p>());</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    		<span class=n>printf</span><span class=p>(</span><span class=s>&#34;(parent) PID: %d PPID: %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>getpid</span><span class=p>(),</span> <span class=n>getppid</span><span class=p>());</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span></span></span></code></pre></div></details><p>L&rsquo;esecuzione dell&rsquo;esempio precedente ha tre diversi scenari:</p><ol><li>Il figlio viene eseguito dopo il genitore, e il genitore non viene terminato</li></ol><pre tabindex=0><code>(genitore) PID: 402 PPID: 350
(figlio) PID: 403 PPID: 402
</code></pre><ol start=2><li>Il processo figlio viene eseguito prima del processo del genitore</li></ol><pre tabindex=0><code>(figlio ) PID: 403 PPID: 402
(genitore) PID: 402 PPID: 350
</code></pre><ol start=3><li>Il processo figlio viene eseguito dopo la fine del genitore (processo zombie!)</li></ol><pre tabindex=0><code>(genitore) PID: 402 PPID: 350
(figlio) PID: 403 PPID: 1
</code></pre><h3 id=controllo-dei-processi-figlio>Controllo dei processi figlio</h3><h4 id=pid_t-waitint-status>pid_t wait(int *status)</h4><p>La chiamata di sistema wait attende che uno dei figli del processo chiamante termini. (vedere waitpid per l&rsquo;argomento di ingresso dello stato).</p><p>Le seguenti azioni sono eseguite da wait:</p><ul><li>Se il processo chiamante non ha figli non attesi, allora wait restituisce -1 ed errno è ECHILD.</li><li>Se nessun figlio è ancora terminato, allora wait blocca il processo chiamante fino a quando un figlio termina. Se un processo figlio è già terminato, allora wait ritorna immediatamente.</li><li>Se status non è NULL, le informazioni sul processo figlio terminato sono memorizzate nella variabile intera a cui punta lo stato.</li></ul><details><summary><b>Esempio di attesa processo figlio</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>	<span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=mi>3</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=c1>// Fork and ignore fork failures.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>fork</span><span class=p>()</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=n>printf</span><span class=p>(</span><span class=s>&#34;Child %d sleeps %d seconds...</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>getpid</span><span class=p>(),</span> <span class=n>i</span><span class=p>);</span> <span class=c1>// Suspends the calling process for i seconds
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>sleep</span><span class=p>(</span><span class=n>i</span><span class=p>);</span> <span class=n>_exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>pid_t</span> <span class=n>child</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=p>((</span><span class=n>child</span> <span class=o>=</span> <span class=n>wait</span><span class=p>(</span><span class=nb>NULL</span><span class=p>))</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>printf</span><span class=p>(</span><span class=s>&#34;wait() returned child %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>child</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>errno</span> <span class=o>!=</span> <span class=n>ECHILD</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>printf</span><span class=p>(</span><span class=s>&#34;(wait) An unexpected error...</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span></span></span></code></pre></div><p>Esempio di output:</p><pre tabindex=0><code>user@localhost[~]$ ./example_wait child 75 sleeps 1 seconds
child 76 sleeps 2 seconds
child 77 sleeps 3 seconds
wait() returned child 75
wait() returned child 76
wait() returned child 77
</code></pre></details><p>Che cosa succede ad un processo figlio che termina prima che il processo padre abbia l&rsquo;opportunità di invocare la wait?</p><p>Il kernel affronta questa situazione trasformando il processo figlio terminato in un processo zombie. Questo significa che la maggior parte delle risorse detenute dal processo figlio vengono rilasciate al sistema. Le uniche parti del processo terminato ancora mantenute sono:</p><ol><li>il suo ID di processo;</li><li>il suo stato di terminazione;</li><li>le statistiche di utilizzo delle risorse.</li></ol><p>Se il processo padre termina senza chiamare wait, allora il processo figlio zombie viene &ldquo;adottato&rdquo; dal processo init, che eseguirà una chiamata di sistema wait qualche tempo dopo.</p><h4 id=pid_t-waitpidpid_t-pid-int-status-int-options>pid_t waitpid(pid_t pid, int *status, int options);</h4><p>La chiamata di sistema waitpid sospende l&rsquo;esecuzione del processo chiamante finché un figlio specificato dall&rsquo;argomento pid non ha cambiato stato.</p><p>L&rsquo;argomento status è lo stesso di wait. Il valore del pid determina quale processo figlio vogliamo aspettare.</p><ul><li>pid ≥ 0, aspetta il processo figlio che ha PID uguale a pid.</li><li>pid = 0, aspetta qualsiasi processo figlio nel gruppo di processi dello stesso chiamante .</li><li>pid = -1, aspetta qualsiasi processo figlio.</li><li>pid &lt; -1, aspetta qualsiasi processo figlio nel gruppo di processi |pid|.</li></ul><p>L&rsquo;argomento options della chiamata di sistema waitpid è un OR di zero o alpiù delle seguenti costanti:</p><ul><li>WUNTRACED: ritorna quando un processo figlio viene fermato da un segnale o termina.</li><li>WCONTINUED: ritorna quando un processo figlio è stato ripreso dalla consegna di un segnale SIGCONT.</li><li>WNOHANG: se nessun processo figlio specificato da pid ha ancora cambiato stato, allora ritorna immediatamente, invece di bloccare (cioè, eseguire un &ldquo;poll&rdquo;). In questo caso, il valore di ritorno di waitpid è 0.</li><li>0: allora waitpid aspetta solo i processi figli terminati.</li></ul><details><summary><b>Esempio 1 con la waitpid</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>pid_t</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>3</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=n>pid</span> <span class=o>=</span> <span class=n>fork</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=c1>// Code executed by the child process...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>_exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// The parent process only waits for the last created child
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>waitpid</span><span class=p>(</span><span class=n>pid</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span></span></span></code></pre></div></details><details><summary><b>Esempio 2 con la waitpid</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>pid_t</span> <span class=n>pid</span> <span class=o>=</span> <span class=n>fork</span><span class=p>();</span> 
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Code executed by the child process
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Waiting for a terminated/stopped | resumed child process.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>waitpid</span><span class=p>(</span><span class=n>pid</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>WUNTRACED</span> <span class=o>|</span> <span class=n>WCONTINUED</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></details><p>Il valore di stato impostato da waitpid, e wait, ci permette di distinguere i seguenti eventi per un processo figlio:</p><ol><li><p><strong>Il processo figlio è terminato chiamando exit (o uscita).</strong><br>La macro <code>WIFEXITED</code> restituisce true se il processo figlio è uscito normalmente.
La macro <code>WEXITSTATUS</code> restituisce lo stato di uscita del processo figlio.
<details><summary><b>Esempio situazione 1</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>waitpid</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>status</span><span class=p>,</span> <span class=n>WUNTRACED</span> <span class=o>|</span> <span class=n>WCONTINUED</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>WIFEXITED</span><span class=p>(</span><span class=n>status</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Child exited, status=%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>WEXITSTATUS</span><span class=p>(</span><span class=n>status</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></details></p></li><li><p><strong>Il processo figlio è stato terminato con la consegna di un segnale non gestito.</strong><br>La macro <code>WIFSIGNALED</code> restituisce true se il bambino è stato ucciso da un segnale. La macro <code>WTERMSIG</code> restituisce il numero del segnale che ha causato la fine del processo.
<details><summary><b>Esempio situazione 2</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>waitpid</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>status</span><span class=p>,</span> <span class=n>WUNTRACED</span> <span class=o>|</span> <span class=n>WCONTINUED</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>WIFSIGNALED</span><span class=p>(</span><span class=n>status</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;child killed by signal %d (%s)&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>WTERMSIG</span><span class=p>(</span><span class=n>status</span><span class=p>),</span> <span class=n>strsignal</span><span class=p>(</span><span class=n>WTERMSIG</span><span class=p>(</span><span class=n>status</span><span class=p>)));</span></span></span></code></pre></div></details></p></li></ol><p>Il strsignal(int sig) è un metodo di string.h che restituisce una stringa che descrive il segnale sig (vedi IPC parte 1).</p><ol start=3><li><p><strong>Il processo figlio è stato interrotto da un segnale</strong>.<br>La macro <code>WIFSTOPPED</code> restituisce true se il processo figlio è stato fermato da un segnale.
La macro <code>WSTOPSIG(status)</code> restituisce il numero del segnale che ha fermato il processo.
<details><summary><b>Esempio situazione 3</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>waitpid</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>status</span><span class=p>,</span> <span class=n>WUNTRACED</span> <span class=o>|</span> <span class=n>WCONTINUED</span><span class=p>);</span> <span class=k>if</span> <span class=p>(</span><span class=n>WIFSTOPPED</span><span class=p>(</span><span class=n>status</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=n>printf</span><span class=p>(</span><span class=s>&#34;child stopped by signal %d (%s)</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>WSTOPSIG</span><span class=p>(</span><span class=n>status</span><span class=p>),</span> <span class=n>strsignal</span><span class=p>(</span><span class=n>WSTOPSIG</span><span class=p>(</span><span class=n>status</span><span class=p>)));</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></details></p></li><li><p><strong>Il processo figlio è stato ripreso da un segnale SIGCONT.</strong><br>La macro <code>WIFCONTINUED</code> restituisce true se il processo figlio è stato ripreso dalla consegna di SIGCONT.
<details><summary><b>Esempio 1</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>waitpid</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>status</span><span class=p>,</span> <span class=n>WUNTRACED</span> <span class=o>|</span> <span class=n>WCONTINUED</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>WIFCONTINUED</span><span class=p>(</span><span class=n>status</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;child resumed by a SIGCONT signal</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></details>oppure
<details><summary><b>Esempio 2</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>waitpid</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>status</span><span class=p>,</span> <span class=n>WCONTINUED</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>printf</span><span class=p>(</span><span class=s>&#34;child resumed by a SIGCONT signal</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span></span></span></code></pre></div></details></p></li></ol><h3 id=esecuzione-di-programmi-exec>Esecuzione di programmi (exec)</h3><h4 id=funzioni-della-libreria-exec>Funzioni della libreria exec</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// None of the following returns on success, all return -1 on error.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>execl</span> <span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>path</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>arg</span><span class=p>,</span> <span class=p>...</span> <span class=p>);</span> <span class=c1>// ... variadic functions
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>execlp</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>path</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>arg</span><span class=p>,</span> <span class=p>...</span> <span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>execle</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>path</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>arg</span><span class=p>,</span> <span class=p>...</span> <span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=k>const</span> <span class=n>envp</span><span class=p>[]);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>execv</span> <span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>path</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=k>const</span> <span class=n>argv</span><span class=p>[]);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>execvp</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>path</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=k>const</span> <span class=n>argv</span><span class=p>[]);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>execve</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>path</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=k>const</span> <span class=n>argv</span><span class=p>[],</span> <span class=kt>char</span> <span class=o>*</span><span class=k>const</span> <span class=n>envp</span><span class=p>[]);</span></span></span></code></pre></div><p>Nota: la lista degli argomenti deve essere terminata da un puntatore NULL e, poiché queste sono funzioni variabili, questo puntatore deve essere cast (char *) NULL.</p><table><thead><tr><th>Funzione</th><th>path</th><th>arg</th><th>environment envp</th></tr></thead><tbody><tr><td>exec<strong>l</strong></td><td>path assoluto</td><td>lista</td><td>environ del chiamante</td></tr><tr><td>exec<strong>lp</strong></td><td>nome del file</td><td>lista</td><td>environ del chiamante</td></tr><tr><td>exec<strong>le</strong></td><td>path assoluto</td><td>lista</td><td>array</td></tr><tr><td>exec<strong>v</strong></td><td>path assoluto</td><td>array</td><td>environ del chiamante</td></tr><tr><td>exec<strong>vp</strong></td><td>nome del file</td><td>array</td><td>environ del chiamante</td></tr><tr><td>exec<strong>ve</strong></td><td>path assoluto</td><td>array</td><td>array</td></tr></tbody></table><details><summary><b>Programma di esempio con la execv</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>printf</span><span class=p>(</span><span class=s>&#34;PID of example.c = %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>getpid</span><span class=p>());</span>
</span></span><span class=line><span class=cl>	<span class=kt>char</span> <span class=o>*</span><span class=n>args</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span><span class=s>&#34;Hello&#34;</span><span class=p>,</span> <span class=s>&#34;C&#34;</span><span class=p>,</span> <span class=s>&#34;Programming&#34;</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>};</span>
</span></span><span class=line><span class=cl>	<span class=n>execv</span><span class=p>(</span><span class=s>&#34;./hello&#34;</span><span class=p>,</span> <span class=n>args</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>printf</span><span class=p>(</span><span class=s>&#34;Back to example.c&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></details><details><summary><b>Programma di esempio con il pid</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>printf</span><span class=p>(</span><span class=s>&#34;We are in hello.c</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>printf</span><span class=p>(</span><span class=s>&#34;PID of hello.c = %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>getpid</span><span class=p>());</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><pre tabindex=0><code>user@localhost[~]$ gcc -o example example.c
user@localhost[~]$ gcc -o hello hello.c
user@localhost[~]$ ./example
PID of example.c = 4733
We are in Hello.c
PID of hello.c = 4733
</code></pre></details><p>TODO: mancano gli altri esempi su execl</p><h3 id=osservazioni-finali-sulle-funzioni-della-libreria-exec>Osservazioni finali sulle funzioni della libreria exec</h3><p>Quello che dovreste sempre tenere a mente quando usate una funzione exec:</p><ul><li>Il parametro di input del programma punta ad un eseguibile;</li><li>Le liste e gli array sono sempre terminati con un puntatore NULL <code>(char \*)NULL</code>;</li><li>Per convenzione, il primo elemento di argv è il nome del programma;</li><li>Tutte le funzioni exec non restituiscono alcun risultato in caso di successo.</li></ul><footer><p>Contenuto basato sulle slide del corso di Sistemi Operativi A.A Laboratorio 2021-2022 UniVR. Copyright degli autori delle slide originali.</p></footer></div></body></html>