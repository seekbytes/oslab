<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Tutte le lezioni on OSLAB</title><link>https://seekbytes.github.io/oslab/lezioni/</link><description>Recent content in Tutte le lezioni on OSLAB</description><generator>Hugo -- gohugo.io</generator><language>it</language><lastBuildDate>Tue, 03 May 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://seekbytes.github.io/oslab/lezioni/index.xml" rel="self" type="application/rss+xml"/><item><title>Lezione 8 - MentOS Buddy System</title><link>https://seekbytes.github.io/oslab/lezioni/8-mentos-buddy-system/</link><pubDate>Tue, 03 May 2022 00:00:00 +0000</pubDate><guid>https://seekbytes.github.io/oslab/lezioni/8-mentos-buddy-system/</guid><description>Gestione della memoria fisica In un sistema a 32 bit, i 4GB di spazio di indirizzamento della RAM sono divisi in pagine frammentate. Il processore x86 nella modalità 32 bit supporta pagine di 4KB, 2MB oppure 4MB. 4 Kybte è la tipica dimensione di una pagina frammentata.
Per il kernel, le pagine frammentate nella memoria fisica sono l&amp;rsquo;unità base per la gestione della memoria.
Page descriptor Il kernel deve tenere traccia dello stato corrente di ogni pagina.</description></item><item><title>Lezione 7.A - Struttura di MentOS</title><link>https://seekbytes.github.io/oslab/lezioni/7-a-struttura-mentos/</link><pubDate>Tue, 26 Apr 2022 00:00:00 +0000</pubDate><guid>https://seekbytes.github.io/oslab/lezioni/7-a-struttura-mentos/</guid><description>L&amp;rsquo;informatica: una ricetta per il divertimento Dal dizionario &amp;ldquo;fun&amp;rdquo;: divertimento. No, sbagliato. Perdere è divertente! In ogni modo, ti tiene occupato. Vincere non è tutto, ma anche perdere fa schifo.
Introduzione a MentOS MentOS è un sistema operativo open-source per scopi didattici e può essere scaricato da Github. Potete trovare i contributors su github.
Struttura di MentOS MentOS (root):
doc: documentazione di MentOS files: lista di file visibili all&amp;rsquo;interno di MentOS, una volta eseguiti initscp: programma per preparare il filesystem third_party: compiler assembly (NASM) MentOS: il codice sorgente del sistema operativo inc: headers src: codice sorgente c Dentro src/inc, possiamo trovare</description></item><item><title>Lezione 7.B - System Call MentOS</title><link>https://seekbytes.github.io/oslab/lezioni/7-b-mentos-system-call/</link><pubDate>Tue, 26 Apr 2022 00:00:00 +0000</pubDate><guid>https://seekbytes.github.io/oslab/lezioni/7-b-mentos-system-call/</guid><description>Preparazione per l&amp;rsquo;esercitazione Salva il tuo lavoro! Esempio: MentOS/src/process/scheduler_algorithm.c. Ripristina la repo di lavoro, riportandola allo stato originale con git reset --hard. Aggiorna la repo di lavoro con git pull Cambia branch di git utilizzando git checkout --track origin/feature/Feature-DeadlockEsercise. System Call Ingredienti Gli ingredienti sono:
una funzione kernel-side una funzione user-side un numero univoco associato alla system call Per esempio:
funzione kernel-side int sys_open(const char *pathname, int flags, mode t mode); funzione user-side int open(const char *pathname, int flags, mode t mode); numero univoco associato alla system call #define __NR_open 5 Struttura delle cartelle per l&amp;rsquo;esercizio inc/sys/unistd.</description></item><item><title>Lezione 7.C - MentOS Deadlock</title><link>https://seekbytes.github.io/oslab/lezioni/7-c-mentos-deadlock/</link><pubDate>Tue, 26 Apr 2022 00:00:00 +0000</pubDate><guid>https://seekbytes.github.io/oslab/lezioni/7-c-mentos-deadlock/</guid><description>Aspetti teorici Definizione di Deadlock Stato di un sistema concorrente con risorse condivise tra processi, in cui almeno un singolo processo è in attesa di un&amp;rsquo;acquisizione di risorse che può essere rilasciata da un altro processo senza risoluzione. Se vuoi evitare il deadlock devi prevenire il verificarsi di almeno di una delle seguenti condizioni:
mutua esclusione hold and wait no pre-emption attesa circolare Definizione di Stato Safe Lo stato del sistema è sicuro se è possibile trovare una sequenza di allocazioni di risorse che soddisfano i requisiti delle risorse dei compiti, altrimenti non è sicuro.</description></item><item><title>Lezione 6 - Pipe e FIFO</title><link>https://seekbytes.github.io/oslab/lezioni/6-pipe-fifo/</link><pubDate>Tue, 05 Apr 2022 00:00:00 +0000</pubDate><guid>https://seekbytes.github.io/oslab/lezioni/6-pipe-fifo/</guid><description>Concetti fondamentali Una PIPE è un flusso di dati in byte che permette a processi di scambiare byte. Tecnicalmente parlando è un buffer nella memoria del kernel. Una PIPE ha le seguenti proprietà:
è unidirezionale. I dati viaggiano solo in una direzione. Un&amp;rsquo;estremità di una PIPE è utilizzata per scrivere, l&amp;rsquo;altra per leggere.
i dati passano dalla PIPE in modo sequenziale. I byte sono letti da una PIPE nell&amp;rsquo;esatto ordine in cui sono stati scritti.</description></item><item><title>Lezione 5 - Memoria condivisa e coda di messaggi</title><link>https://seekbytes.github.io/oslab/lezioni/5-memoria-condivisa-coda-di-messaggi/</link><pubDate>Tue, 29 Mar 2022 00:00:00 +0000</pubDate><guid>https://seekbytes.github.io/oslab/lezioni/5-memoria-condivisa-coda-di-messaggi/</guid><description>Memoria condivisa Concetti fondamentali Una memoria condivisa è un segmento di memoria fisica gestito dal Kernel, che permette a due o più processi di scambiarsi dati. Una volta collegata, anche più di una volta, la memoria condivisa fa parte dello spazio di indirizzamento virtuale del processo, e non è richiesto alcun intervento del kernel. I dati scritti in una memoria condivisa sono immediatamente disponibili a tutti gli altri processo che condividono lo stesso segmento.</description></item><item><title>Lezione 4.A - IPC e Semafori</title><link>https://seekbytes.github.io/oslab/lezioni/4-a-semafori-ipc/</link><pubDate>Mon, 10 Jan 2022 00:00:00 +0000</pubDate><guid>https://seekbytes.github.io/oslab/lezioni/4-a-semafori-ipc/</guid><description>Definizione di Unix System V Unix System V è una delle prime versioni commerciali del sistema operativo Unix del sistema operativo Unix. È stato originariamente sviluppato da AT&amp;amp;T e rilasciato per la prima volta nel 1983. Sono state rilasciate quattro versioni principali di System V, numerate 1, 2, 3, e 4. SystemV è talvolta abbreviato in SysV. Definizione di Comunicazione Tra Processi La comunicazione interprocesso (IPC) si riferisce a meccanismi che coordinano le attività tra processi cooperanti.</description></item><item><title>Lezione 4.B - IPC e Segnali</title><link>https://seekbytes.github.io/oslab/lezioni/4-b-segnali-ipc/</link><pubDate>Mon, 10 Jan 2022 00:00:00 +0000</pubDate><guid>https://seekbytes.github.io/oslab/lezioni/4-b-segnali-ipc/</guid><description>Concetti fondamentali Un segnale è una notifica a un processo che si è verificato un evento. Essi interrompono il normale flusso di esecuzione di un programma; nella maggior parte dei casi, non è possibile prevedere esattamente quando un segnale arriverà.
Si dice che un segnale sia generato da qualche evento. Una volta generato, un segnale viene successivamente consegnato ad un processo. Tra il momento in cui viene generato e il momento in cui viene consegnato, si dice che un segnale è in sospeso.</description></item><item><title>Lezione 3.A - Fondamentali di MentOS</title><link>https://seekbytes.github.io/oslab/lezioni/3-mentos/</link><pubDate>Mon, 29 Nov 2021 00:00:00 +0000</pubDate><guid>https://seekbytes.github.io/oslab/lezioni/3-mentos/</guid><description>Che cosa è? MentOS è un sistema operativo open-source utilizzato per scopi didattici. MentOS può essere scaricato dalla repository Github gratuita: github.com/MentOS. L&amp;rsquo;obiettivo di MentOS è di fornire un ambiente progettuale che sia abbastanza realistico da mostrare come funziona un vero sistema operativo, ma, allo stesso tempo, abbastanza semplice che gli studenti possano capirlo e modificarlo in modo significativo.
Ma se ci sono così tanti sistemi operativi, perché qualcuno ha scritto MentOS?</description></item><item><title>Lezione 3.B - MentOS Scheduling</title><link>https://seekbytes.github.io/oslab/lezioni/3-b-mentos-scheduling/</link><pubDate>Mon, 29 Nov 2021 00:00:00 +0000</pubDate><guid>https://seekbytes.github.io/oslab/lezioni/3-b-mentos-scheduling/</guid><description>Process descriptor task_struct è la struttura dati utilizzata dal kernel per rappresentare un processo.
struct task_struct { pid_t pid; // the process identifier unsigned long state; // the current process’s state struct task_struct *parent; // pointer to parent process struct list_head children; // list of children process struct list_head siblings; // list of siblings process struct mm_struct *mm; // memory descriptor struct sched_entity se; // time accounting (aka schedule entity) struct thread_struct thread; // context of process struct list_head run_list ; // pointer to the process into the scheduler } PID Process Identifier (PID) è un valore numerico che identifica un processo.</description></item><item><title>Lezione 2 - Processi</title><link>https://seekbytes.github.io/oslab/lezioni/2-processi/</link><pubDate>Mon, 08 Nov 2021 00:00:00 +0000</pubDate><guid>https://seekbytes.github.io/oslab/lezioni/2-processi/</guid><description>Ripasso Definizione di Processo Un processo è un&amp;rsquo;istanza di un programma in esecuzione. Dal punto di vista del kernel, un processo consiste di:
memoria user-space (nello spazio utente) contenente il codice del programma, le variabili utilizzate nel codice, e una serie di strutture dati del kernel che mantengono informazioni riguardo lo stato del processo (esempio: tabelle delle pagine, tabella dei file aperti, segnali da inviare, l&amp;rsquo;utilizzo delle risorse del processo e i limiti.</description></item><item><title>Lezione 0 - Introduzione a Sistemi Operativi Laboratorio</title><link>https://seekbytes.github.io/oslab/lezioni/0-sistemi-operativi-laboratorio/</link><pubDate>Fri, 29 Oct 2021 00:00:00 +0000</pubDate><guid>https://seekbytes.github.io/oslab/lezioni/0-sistemi-operativi-laboratorio/</guid><description>Docenti Corso di Sistemi Operativi, Anno Accademico 2021/2022 [Docente (nome.cognome@univr.it)]
Laboratorio Teoria (Squadre riunite):
Florenc Demrozi - Lunedì (08:30 - 11:30) - Aula Magna CV3 Esercitazioni (Matricole pari):
Alberto Castellini - Giovedì (13:30 - 16:30) - Lab. Delta Esercitazioni (Matricole dispari):
Alberto Castellini - Venerdì (08:30 - 11:30) - Lab. Delta Roadmap Roadmap:
I° Semestre: Fundamental Concepts &amp;amp; Filesystem Processi (fork, exec, wait) Linux Introduzione a MentOS &amp;amp; MentOS Scheduling Inter-process communication (IPC) Semafori II° Semestre: Inter-process communication (IPC) Signal, Pipe, FiFo Inter-process communication (IPC) Messaggi, Code Inter-process communication (IPC) Shared Memory MentOS memory Management Esami :) :( :/ La roadmap potrebbe essere soggetta a variazioni.</description></item><item><title>Lezione 1.A - Concetti fondamentali: Processi e Programmi</title><link>https://seekbytes.github.io/oslab/lezioni/1-a-concetti-fondamentali/</link><pubDate>Fri, 29 Oct 2021 00:00:00 +0000</pubDate><guid>https://seekbytes.github.io/oslab/lezioni/1-a-concetti-fondamentali/</guid><description>Processi e programmi Definizione di Processo Un processo è un&amp;rsquo;istanza di un programma in esecuzione. Definizione di Programma Un programma è un file binario che contiene una serie di informazioni che descrive come strutturare il processo a tempo di esecuzione. Dal punto di vista del kernel, un processo consiste di:
memoria user-space (nello spazio utente) contenente il codice del programma, le variabili utilizzate nel codice, e una serie di strutture dati del kernel che mantengono informazioni riguardo lo stato del processo (esempio: tabelle delle pagine, tabella dei file aperti, segnali da inviare, l&amp;rsquo;utilizzo delle risorse del processo e i limiti.</description></item><item><title>Lezione 1.B - Concetti fondamentali: File System</title><link>https://seekbytes.github.io/oslab/lezioni/1-b-file-system/</link><pubDate>Fri, 29 Oct 2021 00:00:00 +0000</pubDate><guid>https://seekbytes.github.io/oslab/lezioni/1-b-file-system/</guid><description>File Apertura file (Open) La system call open apre un file esistente. In alternativa, può creare e quindi aprire un nuovo file.
#include &amp;lt;sys/stat.h&amp;gt; #include &amp;lt;fcntl.h&amp;gt; // Ritorna il file descriptor altrimenti -1 in caso di fallimento int open(const char *pathname, int flags, .../*mode_t mode */); Se ha successo, ritorna il file descriptor che è usato per riferirsi al file in tutte le system call successivi. Il file da essere aperto / creato è identificato dall&amp;rsquo;argomento pathname.</description></item></channel></rss>