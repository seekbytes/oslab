<!doctype html><html lang=it><head><meta charset=utf-8><meta name=author content="SeekBytes"><meta name=viewport content="width=device-width,initial-scale=1"><title>Lezione 3.B - MentOS Scheduling</title><link href=https://seekbytes.github.io/oslab/css/style.css rel=stylesheet type=text/css><link href=https://seekbytes.github.io/oslab/css/syntax.css rel=stylesheet type=text/css><link href=https://seekbytes.github.io/oslab/css/print.css rel=stylesheet media=print type=text/css><meta name=description content="Seconda parte di MentOS: scheduling e strutture dati adibite allo scheduler."></head><body class=flex><div class=navbar-lat><div class=links><h2>Indice</h2><nav id=TableOfContents><ul><li><a href=#process-descriptor>Process descriptor</a><ul><li><a href=#pid>PID</a></li><li><a href=#stato-di-un-processo>Stato di un processo</a></li><li><a href=#relazioni-tra-processi>Relazioni tra processi</a></li><li><a href=#time-accounting>Time accounting</a></li><li><a href=#contesto-di-un-processo>Contesto di un processo</a></li></ul></li><li><a href=#scheduler>Scheduler</a><ul><li><a href=#strutture-dati>Strutture dati</a></li><li><a href=#flusso-di-esecuzione-dello-scheduler>Flusso di esecuzione dello scheduler</a></li><li><a href=#algoritmi-di-scheduling-selezionare-il-prossimo-processo>Algoritmi di scheduling: selezionare il prossimo processo</a><ul><li><a href=#round-robin>Round Robin</a></li><li><a href=#highest-priority-first>Highest Priority First</a></li><li><a href=#completely-fair-scheduler>Completely Fair Scheduler</a></li></ul></li><li><a href=#context-switch>Context Switch</a></li></ul></li></ul></nav><h3>Contenuti</h3><ul><li><a href=https://seekbytes.github.io/oslab/lezioni/0-sistemi-operativi-laboratorio/>Lezione 0 - Introduzione a Sistemi Operativi Laboratorio</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/1-a-concetti-fondamentali/>Lezione 1.A - Concetti fondamentali: Processi e Programmi</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/1-b-file-system/>Lezione 1.B - Concetti fondamentali: File System</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/2-processi/>Lezione 2 - Processi</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/3-mentos/>Lezione 3.A - Fondamentali di MentOS</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/3-b-mentos-scheduling/>Lezione 3.B - MentOS Scheduling</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/4-a-semafori-ipc/>Lezione 4.A - IPC e Semafori</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/4-b-segnali-ipc/>Lezione 4.B - IPC e Segnali</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/5-memoria-condivisa-coda-di-messaggi/>Lezione 5 - Memoria condivisa e coda di messaggi</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/6-pipe-fifo/>Lezione 6 - Pipe e FIFO</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/7-a-struttura-mentos/>Lezione 7.A - Struttura di MentOS</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/7-b-mentos-system-call/>Lezione 7.B - System Call MentOS</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/7-c-mentos-deadlock/>Lezione 7.C - MentOS Deadlock</a></li></ul><a href=../>Sezione principale</a></div></div><div class=content><a href=https://seekbytes.github.io/oslab/ id=returnBack>Ritorna indietro</a><h1>Lezione 3.B - MentOS Scheduling</h1><p class=details>Pubblicato il 11/29/21 da SeekBytes – 2095 parole</p><h2 id=process-descriptor>Process descriptor</h2><p><code>task_struct</code> è la struttura dati utilizzata dal kernel per rappresentare un processo.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>task_struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>pid_t</span> <span class=n>pid</span><span class=p>;</span> <span class=c1>// the process identifier
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>state</span><span class=p>;</span> <span class=c1>// the current process’s state
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>struct</span> <span class=n>task_struct</span> <span class=o>*</span><span class=n>parent</span><span class=p>;</span> <span class=c1>// pointer to parent process
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>struct</span> <span class=n>list_head</span> <span class=n>children</span><span class=p>;</span> <span class=c1>// list of children process
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>struct</span> <span class=n>list_head</span> <span class=n>siblings</span><span class=p>;</span> <span class=c1>// list of siblings process
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>struct</span> <span class=n>mm_struct</span> <span class=o>*</span><span class=n>mm</span><span class=p>;</span> <span class=c1>// memory descriptor
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>struct</span> <span class=n>sched_entity</span> <span class=n>se</span><span class=p>;</span> <span class=c1>// time accounting (aka schedule entity)
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>struct</span> <span class=n>thread_struct</span> <span class=kr>thread</span><span class=p>;</span> <span class=c1>// context of process
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>struct</span> <span class=n>list_head</span> <span class=n>run_list</span> <span class=p>;</span> <span class=c1>// pointer to the process into the scheduler
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></div><h3 id=pid>PID</h3><p>Process Identifier (PID) è un valore numerico che identifica un processo. Quando un nuovo processo viene creato. un nuovo PID viene generato sommando 1 all&rsquo;ultimo PID assegnato.
In Linux, il valore massimo per un PID è <code>32768</code>. Quando il valore massimo del PID è raggiunto, l&rsquo;ultimo PID assegnato viene riportato a 0 prima di cercare un nuovo PID.
La macro <code>RESERVED_PID</code> (di solito impostata a 300) è definita per riservare i PID ai processi di sistema e ai demoni, cioè ai processi che forniscono un servizio (ad esempio un server web). Tutti i processi dell&rsquo;utente hanno PID maggiori di <code>RESERVED_PID</code>.</p><h3 id=stato-di-un-processo>Stato di un processo</h3><p>Lo stato del processo è un valore numerico che descrive lo stato attuale del
processo. Un processo può essere in uno dei seguenti stati:</p><ul><li><code>TASK_RUNNING</code>: o il processo è attualmente in esecuzione, o ha tutte le risorse per essere eseguito tranne la CPU.</li><li><code>TASK_INTERRUPTIBLE</code>: il processo è bloccato (sleep), in attesa di qualche condizione da eseguire. Quando questa condizione esiste, il kernel imposta lo stato del processo a <code>TASK_RUNNING</code>. Il processo inoltre si risveglia e diventa eseguibile se riceve un segnale (es, risorse rilasciate).</li><li><code>TASK_UNINTERRUPTIBLE</code>: questo stato è identico a <code>TASK_INTERRUPTIBLE</code> ma non dipende da un segnale specifico, deve aspettare senza interruzione per una specifica chiamata weak-up (ad esempio, task in attesa di dati trasferiti dal blocco dev al buffer).</li><li><code>TASK_STOPPED</code>: l&rsquo;esecuzione del processo si è fermata; il compito non è in esecuzione né è idoneo all&rsquo;esecuzione.</li><li><code>EXIT_ZOMBIE</code>: l&rsquo;esecuzione del processo è terminata, ma il processo padre non ha ancora emesso una chiamata di sistema <code>wait(0)</code> o <code>waitpid()</code> per restituire informazioni sul processo morto.</li><li><code>EXIT_DIED</code>: Lo stato finale: il processo è stato rimosso dal sistema perché il processo padre ha appena emesso una chiamata di sistema <code>wait()</code> o una chiamata di sistema <code>waitpid()</code> per esso.</li></ul><h3 id=relazioni-tra-processi>Relazioni tra processi</h3><p>I processi creati da un programma hanno una relazione genitore/figlio. Quando un processo crea più figli, questi figli hanno relazioni &ldquo;fraterne&rdquo;.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>task_struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>pid_t</span> <span class=n>pid</span><span class=p>;</span> <span class=c1>// the process identifier
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>struct</span> <span class=n>task_struct</span> <span class=o>*</span><span class=n>parent</span><span class=p>;</span> <span class=c1>// pointer to parent process
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>struct</span> <span class=n>list_head</span> <span class=n>children</span><span class=p>;</span> <span class=c1>// list of children process
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>struct</span> <span class=n>list_head</span> <span class=n>siblings</span><span class=p>;</span> <span class=c1>// list of siblings process
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></div><p>Campi della <code>task_struct</code> che descrivono le relazioni tra i processi:</p><ul><li>parent: puntatore al genitore del processo;</li><li>children: La testa della lista che contiene tutti i figli creati dal processo.</li><li>sibling: La testa della lista che contiene tutti i figli creati dal genitore del processo.</li></ul><h3 id=time-accounting>Time accounting</h3><p>La struttura <code>sched_entity</code> se di una task_struct riporta la priorità e i tempi di esecuzione di un processo.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>task_struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>//..
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>struct</span> <span class=n>sched_entity</span> <span class=n>se</span><span class=p>;</span> <span class=c1>// time accounting (aka schedule entity)
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//..
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>sched_entity</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>prio</span><span class=p>;</span> <span class=c1>// priority
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>time_t</span> <span class=n>start_runtime</span><span class=p>;</span> <span class=c1>// start execution time
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>time_t</span> <span class=n>exec_start</span><span class=p>;</span> <span class=c1>// last context switch time
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>time_t</span> <span class=n>sum_exec_runtime</span><span class=p>;</span> <span class=c1>// overall execution time
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>time_t</span> <span class=n>vruntime</span><span class=p>;</span> <span class=c1>// weighted execution time
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></div><p><strong>prio</strong>:
Definisce la priorità di esecuzione di un processo. Ha un valore nell&rsquo;intervallo
[100, 139], dove 100 significa la massima priorità e 139 significa la
priorità più bassa.
Per impostazione predefinita, la priorità di un nuovo processo generato è 120.
Un processo può aumentare/diminuire il suo valore di prio usando la chiamata di sistema
<code>nice(inc)</code>, che prende come parametro di input un valore nell&rsquo;intervallo [-20, 19].
Esempi:</p><ul><li><code>nice(1)</code> (incrementa il valore di prio del processo chiamante di 1 unità) 120 ⇒ 121</li><li><code>nice(-5)</code> (decrementa il valore di prio del processo chiamante di -5 unità) 120⇒
115</li></ul><p>Altri campi di questa struttura sono:</p><ul><li><strong>start_runtime</strong>: il tempo di esecuzione del sistema che riporta quando il processo è stato eseguito nella CPU.</li><li><strong>exec_start</strong>: il tempo di esecuzione del sistema che riporta quando il processo è stato eseguito nella CPU.</li><li><strong>sum_exec_runtime</strong>: il tempo complessivo di esecuzione speso dal processo nella CPU.</li><li><strong>vruntime</strong>: il tempo di esecuzione virtuale, cioè il tempo di esecuzione globale ponderato trascorso dal processo nella CPU (vedi CFS).</li></ul><h3 id=contesto-di-un-processo>Contesto di un processo</h3><p>La thread_struct di un task struct riporta il contesto di un processo ogni volta che viene scambiato.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>task_struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// ..
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>struct</span> <span class=n>thread_struct</span> <span class=kr>thread</span><span class=p>;</span> <span class=c1>// context of process
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// ..
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>thread_struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>uint32_t</span> <span class=n>ebp</span><span class=p>;</span> <span class=c1>// base pointer register
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>uint32_t</span> <span class=n>esp</span><span class=p>;</span> <span class=c1>// stack pointer register
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>uint32_t</span> <span class=n>ebx</span><span class=p>;</span> <span class=c1>// base register
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>uint32_t</span> <span class=n>edx</span><span class=p>;</span> <span class=c1>// data register
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>uint32_t</span> <span class=n>ecx</span><span class=p>;</span> <span class=c1>// counter
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>uint32_t</span> <span class=n>eax</span><span class=p>;</span> <span class=c1>// accumulator register
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>uint32_t</span> <span class=n>eip</span><span class=p>;</span> <span class=c1>// Instruction Pointer Register
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>uint32_t</span> <span class=n>eflags</span><span class=p>;</span> <span class=c1>// flag register
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>bool_t</span> <span class=n>fpu_enabled</span><span class=p>;</span> <span class=c1>// is FPU enabled?
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>savefpu</span> <span class=n>fpu_register</span><span class=p>;</span> <span class=c1>// FPU context
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></div><h2 id=scheduler>Scheduler</h2><h3 id=strutture-dati>Strutture dati</h3><p>La struttura dati runqueue è la struttura dati più importante dello scheduler. Raccoglie tutti i processi di sistema in stato di esecuzione.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>runqueue</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>nr_running</span><span class=p>;</span> <span class=c1>// number of processes in running state
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>struct</span> <span class=n>task_struct</span> <span class=o>*</span><span class=n>curr</span><span class=p>;</span> <span class=c1>// pointer to current running process
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>struct</span> <span class=n>list_head_t</span> <span class=n>queue</span><span class=p>;</span> <span class=c1>// list of processes in running state
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></div><p>Fate attenzione! <code>queue</code> è la list_head_t di una lista circolare, doppiamente collegata, che raccoglie tutti i processi di sistema in stato di esecuzione. Di conseguenza, un campo <code>run_list</code> di tipo struct <code>list_head</code> viene aggiunto nella struct <code>task_struct</code>. (Vedi le diapositive concetti fondamentali per maggiori dettagli).</p><h3 id=flusso-di-esecuzione-dello-scheduler>Flusso di esecuzione dello scheduler</h3><p>Lo scheduler viene chiamato dopo la gestione di un interrupt/exception. In dettaglio, le seguenti operazioni sono eseguite dallo scheduler:</p><ol><li>aggiorna le variabili di contabilità temporale del processo corrente;</li><li>prova a svegliare un processo in attesa. Se una condizione di attesa è soddisfatta, un processo viene svegliato impostando il suo stato su running, e inserendolo nella runqueue (argomento non affrontato nelle diapositive attuali);</li><li>esegue l&rsquo;algoritmo di scheduling per scegliere il prossimo processo da eseguire da parte della CPU dalla runqueue;</li><li>esegue il cambio di contesto.</li></ol><h3 id=algoritmi-di-scheduling-selezionare-il-prossimo-processo>Algoritmi di scheduling: selezionare il prossimo processo</h3><p><code>pick_next_task</code> è la funzione chiamata dallo scheduler per ottenere il prossimo processo da eseguire. Secondo l&rsquo;algoritmo di scheduling implementato, il prossimo processo può essere scelto in modo diverso.</p><p>MentOS fornisce i seguenti algoritmi:</p><ul><li><strong>RR</strong>: Round Robin</li><li><strong>Priority</strong> : Highest Priority First.</li><li><strong>CFS</strong> : Completely Fair Scheduler.</li></ul><h4 id=round-robin>Round Robin</h4><p>Round Robin è un algoritmo di programmazione della CPU in cui una fetta di tempo fissa è assegnata ad ogni processo del sistema, in modo ciclico. È semplice, preemptive, facile da implementare e senza starvation.</p><p><strong>Pseudocodice dell&rsquo;algoritmo Round-Robin</strong></p><p>Input: Processo corrente <code>c</code>, lista di processi <code>L</code>
Output: prossimo processo <code>n</code></p><pre tabindex=0><code class=language-pseudocode data-lang=pseudocode>nNode = next(c)
if isHead(L, nNode) then
	nNode = next(nNode)
end if
n = list_entry(nNode)</code></pre><details><summary><b>Implementazione del Round Robin</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>runqueue</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>nr_running</span><span class=p>;</span> <span class=c1>// number of processes in running state
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>struct</span> <span class=n>task_struct</span> <span class=o>*</span><span class=n>curr</span><span class=p>;</span> <span class=c1>// pointer to current running process
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>struct</span> <span class=n>list_head_t</span> <span class=n>queue</span><span class=p>;</span> <span class=c1>// list of processes in running state
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></div><p>Implementazione C dell&rsquo;algoritmo Round Robin:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>task_struct</span> <span class=o>*</span> <span class=nf>pick_next_task</span><span class=p>(</span><span class=k>struct</span> <span class=n>runqueue</span> <span class=o>*</span><span class=n>runqueue</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// nNode = next(c)
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>struct</span> <span class=n>list_head</span> <span class=o>*</span><span class=n>nNode</span> <span class=o>=</span> <span class=n>runqueue</span><span class=o>-&gt;</span><span class=n>curr</span><span class=o>-&gt;</span><span class=n>run_list</span><span class=p>.</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=c1>// if isHead(L, nNode)
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=p>(</span><span class=n>nNode</span> <span class=o>==</span> <span class=o>&amp;</span><span class=n>runqueue</span><span class=o>-&gt;</span><span class=n>queue</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>nNode</span> <span class=o>=</span> <span class=n>nNode</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=c1>// n = entry(nNode)
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>task_struct</span> <span class=o>*</span><span class=n>next</span> <span class=o>=</span> <span class=n>list_entry</span><span class=p>(</span><span class=n>nNode</span><span class=p>,</span> <span class=k>struct</span> <span class=n>task_struct</span><span class=p>,</span> <span class=n>run_list</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></details><p>La programmazione round robin presuppone che tutti i processi siano ugualmente importanti. Questo generalmente non è vero. A volte vorremmo che i processi ad alta intensità di CPU (non interattivi) processi ad alta intensità di CPU (non interattivi) abbiano una priorità inferiore rispetto ai processi interattivi. Inoltre, diversi utenti possono avere uno stato diverso. I processi di un amministratore di sistema possono avere una priorità superiore a quelli di uno studente.</p><p>Questi obiettivi hanno portato all&rsquo;introduzione del Priority Scheduling Algorithm.</p><h4 id=highest-priority-first>Highest Priority First</h4><p>Ogni processo ha una priorità statica. Più piccolo è il numero, più alta è la priorità del processo. Lo scheduler sceglie semplicemente il processo a più alta priorità da eseguire. Un processo è prevenuto ogni volta che un processo a priorità più alta è disponibile nella coda di esecuzione.</p><p><strong>Vantaggio</strong>: lo scheduling prioritario fornisce un buon meccanismo in cui l&rsquo;importanza relativa di ogni processo può essere definita con precisione.
<strong>Svantaggio</strong>: se i processi ad alta priorità utilizzano molto tempo di CPU, i processi a bassa priorità possono morire di fame ed essere rimandati indefinitamente, portando alla starvation.</p><p><strong>Pseudocodice di Highest Priority First</strong></p><p>Input: Processo corrente c, lista di processi L
Output: prossimo processo</p><pre tabindex=0><code class=language-pseudocode data-lang=pseudocode>n = c
for all lNode ∈ L do
	if !isHead(L,lNode) then
		t = list_entry(lNode)
		if priority(t) &lt; priority(n) then
			n = t
		end if
	end if
end for
return n</code></pre><h4 id=completely-fair-scheduler>Completely Fair Scheduler</h4><p>L&rsquo;idea di CFS è semplice: usare la priorità di ogni processo per &ldquo;pesare&rdquo; il suo tempo di tempo di esecuzione (runtime virtuale). I processi con bassa priorità hanno un tempo di esecuzione virtuale che aumenta più velocemente dei processi con una priorità più alta. Lo scheduler sceglie sempre il processo con il tempo di esecuzione virtuale più basso!</p><p>Lo scheduler ha bisogno di conoscere il peso del compito per stimare la sua porzione di tempo della CPU porzione di tempo della CPU. Quindi, il numero di priorità deve essere mappato a tale peso; Questo viene fatto nell&rsquo;array <code>prio_to_weight</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=k>const</span> <span class=kt>int</span> <span class=n>prio_to_weight</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=cm>/* 100 */</span> <span class=mi>88761</span><span class=p>,</span> <span class=mi>71755</span><span class=p>,</span> <span class=mi>56483</span><span class=p>,</span> <span class=mi>46273</span><span class=p>,</span> <span class=mi>36291</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=cm>/* 105 */</span> <span class=mi>29154</span><span class=p>,</span> <span class=mi>23254</span><span class=p>,</span> <span class=mi>18705</span><span class=p>,</span> <span class=mi>14949</span><span class=p>,</span> <span class=mi>11916</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=cm>/* 110 */</span> <span class=mi>9548</span><span class=p>,</span> <span class=mi>7620</span><span class=p>,</span> <span class=mi>6100</span><span class=p>,</span> <span class=mi>4904</span><span class=p>,</span> <span class=mi>3906</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=cm>/* 115 */</span> <span class=mi>3121</span><span class=p>,</span> <span class=mi>2501</span><span class=p>,</span> <span class=mi>1991</span><span class=p>,</span> <span class=mi>1586</span><span class=p>,</span> <span class=mi>1277</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=cm>/* 120 */</span> <span class=mi>1024</span><span class=p>,</span> <span class=mi>820</span><span class=p>,</span> <span class=mi>655</span><span class=p>,</span> <span class=mi>526</span><span class=p>,</span> <span class=mi>423</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=cm>/* 125 */</span> <span class=mi>335</span><span class=p>,</span> <span class=mi>272</span><span class=p>,</span> <span class=mi>215</span><span class=p>,</span> <span class=mi>172</span><span class=p>,</span> <span class=mi>137</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=cm>/* 130 */</span> <span class=mi>110</span><span class=p>,</span> <span class=mi>87</span><span class=p>,</span> <span class=mi>70</span><span class=p>,</span> <span class=mi>56</span><span class=p>,</span> <span class=mi>45</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=cm>/* 135 */</span> <span class=mi>36</span><span class=p>,</span> <span class=mi>29</span><span class=p>,</span> <span class=mi>23</span><span class=p>,</span> <span class=mi>18</span><span class=p>,</span> <span class=mi>15</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></div><p>Un numero di priorità di 120, che è la priorità di un compito normale, è mappato ad un peso di 1024. Si noti che il rapporto tra due voci successive nell&rsquo;array è quasi 1,25. Questo numero è scelto in modo tale che:</p><ul><li>se la priorità di un compito è ridotta di uno, allora ottiene il 10% in più
del tempo di CPU disponibile.</li><li>se la priorità di un compito viene aumentata di uno, allora ottiene il 10% in meno
del tempo di CPU disponibile.</li></ul><p>Dato l&rsquo;array prio_to_weight possiamo aggiornare il tempo di esecuzione virtuale di un processo p, cioè la sua esecuzione complessiva ponderata utilizzando la formula:</p><p><code>vruntime += delta_exec * (NICE_0 LOAD / weight(p))</code></p><p>dove:</p><ul><li><code>vruntime</code> è il tempo di esecuzione virtuale del processo;</li><li><code>delta_exec</code> è l&rsquo;ultima quantità di tempo spesa da p nella CPU;</li><li><code>NICE_0_LOAD</code> è il peso di un compito con priorità normale (1024);</li><li><code>weight(p)</code> è il peso di p definito dall&rsquo;array <code>prio_to_weight</code>.</li></ul><p><strong>Pseudocodice di Completely Fair Scheduler</strong></p><p>Input: Processo corrente <code>c</code>, Elenco dei processi <code>L</code></p><p>Output: processo successivo <code>n</code></p><pre tabindex=0><code class=language-pseudocode data-lang=pseudocode>updateVirtualRuntime(c)
n = c
for all lNode ∈ L do
	if !isHead(L,lNode) then
		t = list_entry(lNode)
		if virtualRuntime(t) &lt; virtualRuntime(n) then
			n = t
		end if
	end if
end for
return n</code></pre><h3 id=context-switch>Context Switch</h3><p>La CPU esegue un cambio di contesto per cambiare il processo eseguito dalla CPU. L&rsquo;esempio seguente mostra i passi eseguiti dal sistema operativo per salvare lo stato del processo corrente (processo 1), e poi riprendere l&rsquo;esecuzione di un processo precedentemente fermato (processo 2).</p><ol><li>Tempo scaduto! È il momento di restituire il controllo della CPU al kernel. Il dispositivo timer alza il segnale INTR e presenta 0 nella linea irq. Quando INTR si alza, la CPU si sposta dal Ring 3 (modalità utente) al Ring 0 (modalità kernel). Dopo che la CPU cambia livello di privilegio della CPU, i valori dei registri della CPU sono &ldquo;pushati&rdquo; nello stack del kernel.</li><li>La CPU inizia l&rsquo;esecuzione di irq 0 (gestore di interrupt per gestire l&rsquo;interrupt 0 dell&rsquo;hardware), che è stato generato dal Timer.</li><li>Lo scheduler viene quindi chiamato per aggiornare le variabili di contabilità temporale del processo interrotto e scegliere il prossimo processo da eseguire. In questo esempio, lo scheduler sceglie il processo 2 come prossimo.</li><li>Il kernel aggiorna la struct del thread della struttura del task struct del processo 1 per salvare il suo contesto.</li><li>Il kernel sostituisce il contesto del processo 1 con il contesto del processo 2 nella sua memoria dello stack.</li><li>Il kernel sposta i valori dal suo stack ai registri della CPU ed esegue un&rsquo;istruzione istruzione di assemblaggio iret, che cambia il livello di privilegio della CPU da Ring 0 (modalità kernel) a Ring 3 (modalità utente).</li><li>Il contesto del processo 2 è nei registri della CPU, infine. La CPU può continuare ad eseguire il codice del processo 2 in modalità utente fino al prossimo cambio di contesto.</li></ol><footer><p>Contenuto basato sulle slide del corso di Sistemi Operativi A.A Laboratorio 2021-2022 UniVR. Copyright degli autori delle slide originali.
<a href=https://github.com/seekbytes/oslab/edit/main/content/lezioni/3_b_mentos.md>Modifica questa pagina</a></p></footer></div></body></html>