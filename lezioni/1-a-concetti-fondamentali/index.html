<!doctype html><html lang=it><head><meta charset=utf-8><meta name=author content="SeekBytes"><meta name=viewport content="width=device-width,initial-scale=1"><title>Lezione 1.A - Concetti fondamentali: Processi e Programmi</title><link href=https://seekbytes.github.io/oslab/css/style.css rel=stylesheet type=text/css><link href=https://seekbytes.github.io/oslab/css/syntax.css rel=stylesheet type=text/css><link href=https://seekbytes.github.io/oslab/css/print.css rel=stylesheet media=print type=text/css><meta name=description content="Introduzione ai processi e programmi, memoria, errori, file descriptor e pagine del manuale."><meta property="og:locale" content="it"><meta name=robots content="index,follow"><meta name=googlebot content="index,follow"></head><body class=flex><div class=navbar-lat><div class=links><h2>Indice</h2><nav id=TableOfContents><ul><li><a href=#processi-e-programmi>Processi e programmi</a></li><li><a href=#configurazione-della-memoria-di-un-processo>Configurazione della memoria di un processo</a></li><li><a href=#panoramica-della-file-descriptor-table>Panoramica della File Descriptor Table</a></li><li><a href=#system-call>System Call</a></li><li><a href=#gestire-gli-errori>Gestire gli errori</a><ul><li><a href=#perror>perror</a></li><li><a href=#strerror>strerror</a></li><li><a href=#errexit>errExit</a></li><li><a href=#comando-strace>Comando strace</a></li></ul></li><li><a href=#tipi-di-dati-del-kernel>Tipi di dati del kernel</a></li><li><a href=#pagine-del-manuale>Pagine del manuale</a></li></ul></nav><h3>Contenuti</h3><ul><li><a href=https://seekbytes.github.io/oslab/lezioni/0-sistemi-operativi-laboratorio/>Lezione 0 - Introduzione a Sistemi Operativi Laboratorio</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/1-a-concetti-fondamentali/>Lezione 1.A - Concetti fondamentali: Processi e Programmi</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/1-b-file-system/>Lezione 1.B - Concetti fondamentali: File System</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/2-processi/>Lezione 2 - Processi</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/3-mentos/>Lezione 3.A - Fondamentali di MentOS</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/3-b-mentos-scheduling/>Lezione 3.B - MentOS Scheduling</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/4-a-semafori-ipc/>Lezione 4.A - IPC e Semafori</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/4-b-segnali-ipc/>Lezione 4.B - IPC e Segnali</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/5-memoria-condivisa-coda-di-messaggi/>Lezione 5 - Memoria condivisa e coda di messaggi</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/6-pipe-fifo/>Lezione 6 - Pipe e FIFO</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/7-a-struttura-mentos/>Lezione 7.A - Struttura di MentOS</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/7-b-mentos-system-call/>Lezione 7.B - System Call MentOS</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/7-c-mentos-deadlock/>Lezione 7.C - MentOS Deadlock</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/8-mentos-buddy-system/>Lezione 8 - MentOS Buddy System</a></li></ul><a href=../>Sezione principale</a></div></div><div class=content><a href=https://seekbytes.github.io/oslab/ id=returnBack>Ritorna indietro</a><h1>Lezione 1.A - Concetti fondamentali: Processi e Programmi</h1><p class=details>Pubblicato il 10/29/21 da SeekBytes – 1632 parole</p><h2 id=processi-e-programmi>Processi e programmi</h2><div class=definition><h3>Definizione di Processo</h3>Un processo è un&rsquo;istanza di un programma in esecuzione.</div><div class=definition><h3>Definizione di Programma</h3>Un programma è un file binario che contiene una serie di informazioni che descrive come strutturare il processo a tempo di esecuzione.</div><p>Dal punto di vista del kernel, un processo consiste di:</p><ul><li>memoria user-space (nello spazio utente) contenente il codice del programma,</li><li>le variabili utilizzate nel codice, e</li><li>una serie di strutture dati del kernel che mantengono informazioni riguardo lo stato del processo (esempio: tabelle delle pagine, tabella dei file aperti, segnali da inviare, l&rsquo;utilizzo delle risorse del processo e i limiti..)</li></ul><h2 id=configurazione-della-memoria-di-un-processo>Configurazione della memoria di un processo</h2><p>Tipica configurazione dello spazio di RAM di un processo:</p><ul><li>il codice di sola lettura contenente le istruzioni macchina sono memorizzate in un segmento chiamato <strong>text</strong></li><li>il segmento di dati inizializzati (contiene le variabili statiche e globali) si chiama <strong>data</strong></li><li>il segmento che contiene variabili statiche e globali <strong>NON</strong> ancora inizializzate si chiama <strong>BSS</strong></li><li>il segmento che contiene le variabile allocate dinamicamente si chiama <strong>heap</strong></li><li>lo <strong>stack</strong> contiene ogni funzione chiamata, i suoi argomenti e tutte le variabili locali</li></ul><details><summary><b>Esempio</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// Variabili globali dichiarate
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>char</span> <span class=n>buffer</span><span class=p>[</span><span class=mi>10</span><span class=p>];</span> <span class=c1>// &lt;- (bss)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>primes</span> <span class=p>[]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>7</span><span class=p>};</span> <span class=c1>// &lt;- (data)
</span></span></span><span class=line><span class=cl><span class=c1>// Implementazione di una funzione
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>method</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=n>a</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// &lt;- (stack)
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>int</span> <span class=n>i</span><span class=p>;</span> <span class=c1>// &lt;- (stack)
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// Entry point del programma
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>main</span> <span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span> <span class=p>{</span> <span class=c1>// &lt;- (stack)
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>static</span> <span class=kt>int</span> <span class=n>key</span> <span class=o>=</span> <span class=mi>123</span><span class=p>;</span> <span class=c1>// &lt;- (data)
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>int</span> <span class=o>*</span><span class=n>p</span><span class=p>;</span> <span class=c1>// &lt;- (stack)
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>p</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mi>10</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>));</span> <span class=c1>// &lt;- (heap)
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>method</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=nf>free</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></details><p>Puoi vedere le dimensioni dei segmenti tramite il comando <code>size</code>.</p><details><summary><b>Esempio 1</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span> <span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=err>\</span><span class=o>*</span><span class=n>argv</span><span class=p>[])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>char</span> <span class=o>*</span><span class=n>string</span> <span class=o>=</span> <span class=s>&#34;ciao&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>string</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=err>‘</span><span class=n>C</span><span class=err>‘</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>string</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Perché ho un segmentation error nel primo esempio? Perché alla riga XX sto tentando di sovrascrivere una struttura dati costante che verrà posizionata nel segmento .text (di sola lettura!).</p></details><details><summary><b>Esempio 2</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span> <span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>char</span> <span class=n>string</span><span class=p>[]</span> <span class=o>=</span> <span class=s>&#34;ciao&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>string</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=err>‘</span><span class=n>C</span><span class=err>‘</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>string</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></details><h2 id=panoramica-della-file-descriptor-table>Panoramica della File Descriptor Table</h2><p>Per ogni processo generato, il Kernel mantiene una tabella (file descriptor table). Ogni entry della tabella è un file descriptor, ovvero un numero positivo che rappresenta una risorsa input/output aperto dal processo (esempio: file, pipe, socket).</p><p>Per convenzione, esistono <strong>sempre</strong> tre file descrittori in un nuovo processo.</p><table><thead><tr><th>File descriptor</th><th>Descrizione</th><th>nome POSIX</th></tr></thead><tbody><tr><td>0</td><td>standard input</td><td><code>STDIN_FILENO</code></td></tr><tr><td>1</td><td>standard output</td><td><code>STDOUT_FILENO</code></td></tr><tr><td>2</td><td>standard error</td><td><code>STDERR_FILENO</code></td></tr></tbody></table><p>Più dettagli sono contenuti nel capitolo riguardo il <a href=/oslab/lezioni/1-b-file-system/>&ldquo;File system&rdquo;</a>.</p><h2 id=system-call>System Call</h2><p>Tipica architettura del sistema operativo:</p><p><img src=../../images/lezioni/1/struttura-sistema-operativo.png alt="Tipica struttura di un sistema operativo"></p><p>Una system call è una entry point controllata che permette ad un processo di richiedere un servizio al Kernel. Per esempio, i servizi che il kernel mette a disposizione includono: creazione di un nuovo processo, esecuzione di operazioni I/O, creazione di una pipe per la comunicazione tra più processi.</p><p>La pagina di manuale <code>syscalls(2)</code> include la lista delle system calls disponibili per Linux. I dettagli tecnici sono disponibili per ogni system call tramite il comando <code>man</code> (vedi sezione &ldquo;manuale&rdquo;).</p><p>Dal punto di vista della programmazione, invocare una system calls è molto simile a chiamare una funzione C. Tuttavia, ciò che avviene dietro quell&rsquo;invocazione è molto differente rispetto ad una chiamata di funzione. Di seguito i passi per l&rsquo;esecuzione di una system call.</p><p><img src=../../images/lezioni/1/system-call-esecuzione.png alt="Esecuzione di una system call"></p><ol><li>l&rsquo;applicazione chiama una system call invocando una funzione di &ldquo;wrapper&rdquo; nella libreria C</li><li>la funzione wrapper: copia gli argomenti della system call dallo stack a registri specifici della CPU e copia il numero di system call nel registro <code>%eax</code>. (Ogni system call ha associato un nome dato dalla libreria standard C e un numero univoco) Infine, il wrapper chiama l&rsquo;interrupt per cambiare modalità da &ldquo;utente&rdquo; a &ldquo;kernel mode&rdquo; (<code>int 0x80</code>)</li><li>il kernel esegue la routine per le system call: salva i valori dei registri nello stack del kernel, controlla la validità del numero della system call e invoca la &ldquo;vera&rdquo; system call (system call service routine)</li><li>La service routine esegue il task richiesto e il risultato è ritornato alla routine</li><li>La routine ripristina i valori dei registri dallo stack del kernel e pone il risultato della system call sullo stack. Simultaneamente, la routine cambia modalità da kernel a user mode e ritorna all&rsquo;esecuzione della funzione wrapper</li><li>Se il valore di ritorno della chiamata di sistema indica un errore, allora la funzione di wrapper imposta una variabile globale chiamata <code>errno</code>. Successivamente, la funzione di wrapper ritorna al chiamante un valore intero indicando il successo o il fallimento della system call.</li></ol><p>Per convenzione, il numero negativo -1 o il puntatore <code>NULL</code> indica un errore alla syscall chiamante.</p><h2 id=gestire-gli-errori>Gestire gli errori</h2><p>La sezione <code>ERRORS</code> nelle pagine del manuale di ogni system call documenta il possibile valore di ritorno indicante un errore. Abitualmente, una system call notifica un errore ritornando -1 come risultato.</p><p>Quando una system call fallisce, la variabile globale intera errno è impostata ad un valore positivo che identifica l&rsquo;errore avvenuto. Includere il file header <code>&lt;errno.h></code> fornisce una dichiarazione di errno, così come un insieme di costanti per i vari numeri di errore.</p><details><summary><b>Utilizzo di ErrNO</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;errno.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=c1>// system call to open a file
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>fd</span> <span class=o>=</span> <span class=nf>open</span><span class=p>(</span><span class=n>pathname</span><span class=p>,</span> <span class=n>flags</span><span class=p>,</span> <span class=n>mode</span><span class=p>);</span> <span class=c1>// BEGIN code handling errors.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>fd</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>errno</span> <span class=o>==</span> <span class=n>EACCES</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Handling not allowed access to the file
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Some other error occurred
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// END code handling errors
</span></span></span></code></pre></div></details><p>Alcune system call (ad esempio <code>getpriority</code>) possono ritornare -1 se hanno successo. Per determinare se un errore accade veramente in questi casi, dobbiamo impostare la variabile <code>errno</code> a 0 prima di chiamare qualsiasi system call. Se l&rsquo;invocazione ritorna -1 e <code>errno</code> non è zero, allora è accaduto un errore.</p><details><summary><b>Esempio con getpriority</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/resource.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// Reset the errno variable to 0
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>errno</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// System call getpriority gets the nice value of a process
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>nice</span> <span class=o>=</span> <span class=nf>getpriority</span><span class=p>(</span><span class=n>which</span><span class=p>,</span> <span class=n>who</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>((</span><span class=n>nice</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>errno</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Handling getpriority errors
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></div></details><h3 id=perror>perror</h3><p>La funzione <code>perror</code> stampa nello standard error la stringa <code>msg</code> seguita da un messaggio che descrive l&rsquo;ultimo errore incontrato durante l&rsquo;ultima invocazione della system call.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>perror</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>msg</span><span class=p>);</span></span></span></code></pre></div><details><summary><b>Semplice esempio dell'utilizzo di perror per stampare un messaggio che descrive l'ultimo errore.</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt; ...</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// System call to open a file.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>fd</span> <span class=o>=</span> <span class=nf>open</span><span class=p>(</span><span class=n>pathname</span><span class=p>,</span> <span class=n>flags</span><span class=p>,</span> <span class=n>mode</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>fd</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span> <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;&lt;Open&gt;&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=c1>// System call to kill the current process.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nf>exit</span><span class=p>(</span><span class=n>EXIT_FAILURE</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=p>...</span></span></span></code></pre></div><p>Output di esempio:
<code>&lt;Open>: No such file or directory</code></p></details><h3 id=strerror>strerror</h3><p>La funzione <code>strerror()</code> ritorna la stringa di errore corrispondente al numero di errore errnum passato come parametro.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>char</span> <span class=o>*</span><span class=nf>strerror</span><span class=p>(</span><span class=kt>int</span> <span class=n>errnum</span><span class=p>);</span></span></span></code></pre></div><p>La stringa ritornata potrebbe essere sovrascritta da una chiamata a strerror(). Se errnum non è riconosciuto come numero, strerror() ritorna una stringa della forma &ldquo;Unkown error nun.&rdquo;</p><p>Esempio dell&rsquo;utilizzo di strerror per stampare un messaggio di errore descrivendolo.</p><details><summary><b>Esempio</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt; ...</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// System call to open a file
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>fd</span> <span class=o>=</span> <span class=nf>open</span><span class=p>(</span><span class=n>path</span><span class=p>,</span> <span class=n>flags</span><span class=p>,</span> <span class=n>mode</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>fd</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Error opening (%s):</span><span class=se>\n\t</span><span class=s>%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>path</span><span class=p>,</span> <span class=nf>strerror</span><span class=p>(</span><span class=n>errno</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=c1>// System call to kill the current process
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>exit</span><span class=p>(</span><span class=n>EXIT_FAILURE</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=p>...</span></span></span></code></pre></div><p>Output di esempio:</p><pre tabindex=0><code>Error opening (myFile.txt):
No such file or directory
</code></pre></details><h3 id=errexit>errExit</h3><p>In queste slide, la funzione <code>errExit</code> viene utilizzata come una scorciatoia per stampare un messaggio e terminare il processo.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>errExit</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>msg</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>perror</span><span class=p>(</span><span class=n>msg</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>	<span class=nf>exit</span><span class=p>(</span><span class=n>EXIT_FAILURE</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p><strong>NON FA PARTE DELA LIBRERIA STANDARD DI C!</strong></p><h3 id=comando-strace>Comando strace</h3><p>Il comando strace permette di vedere quali system call un processo sta utilizzando. Nella sua forma più semplice, viene utilizzato così</p><pre tabindex=0><code>strace command arg...
</code></pre><h2 id=tipi-di-dati-del-kernel>Tipi di dati del kernel</h2><p>Anche in ogni implementazione su Linux, i tipi di dati utilizzati per rappresentare le informazioni possono differire da ogni rilascio. Per esempio: user e group id che venivano rappresentati da 16 bit e poi da 32 bit.</p><p>Per evitare problemi di portabilità, vennero definiti alcuni tipi di dati standard. Ogni tipo viene definito tramite <code>typedef</code> di C. Molti di questi tipi di dati sono nomi che finiscono con la _t per type. La maggior parte sono dichiarate nel file &lt;sys/types.h></p><p>Questa tabella presenta alcuni tipi di dati che andremo ad utilizzare in questo corso.</p><table><thead><tr><th>Tipo di dato</th><th>Reale</th><th>Descrizione</th></tr></thead><tbody><tr><td><code>ssize_t</code></td><td>intero con segno</td><td>per indicare la conta dei byte o per indicare errori</td></tr><tr><td><code>size_t</code></td><td>intero positivo</td><td>per indicare la conta dei byte</td></tr><tr><td><code>off_t</code></td><td>intero con segno</td><td>per indicare l&rsquo;offset del file</td></tr><tr><td><code>mode_t</code></td><td>intero</td><td>permessi dei file e il tipo</td></tr><tr><td><code>pid_t</code></td><td>intero con segno</td><td>processo, gruppo di processi o l&rsquo;id della sezione</td></tr><tr><td><code>uid_t</code></td><td>intero</td><td>identificativo numerico per l&rsquo;utente</td></tr><tr><td><code>gid_t</code></td><td>intero</td><td>identificativo numerico per il gruppo</td></tr><tr><td><code>key_t</code></td><td>tipo aritmetico</td><td>il tipo di IPC System V</td></tr><tr><td><code>time_t</code></td><td>intero o numero floating point</td><td>time in secondi dall&rsquo;Epoch</td></tr><tr><td><code>msgqnum_t</code></td><td>intero senza segno</td><td>conta dei messaggi in una coda</td></tr><tr><td><code>msglen_t</code></td><td>intero positivo</td><td>numero che indica quanti byte sono ammessi in un messaggio</td></tr><tr><td><code>shamatt_t</code></td><td>intero positivo</td><td>conta quanti attacchi ci sono per la memoria condivisa</td></tr></tbody></table><h2 id=pagine-del-manuale>Pagine del manuale</h2><p>Le pagine del manuale sono un insieme di pagine che spiegano ogni comando disponibile sul vostro sistema, incluso ciò che fanno, le specifiche di come eseguirli e quali argomenti della linea di comando accettano. Le pagine di manuale sono accessibili tramite il comando man. Esempio:
man <command></p><p>Una pagina di manuale è solitamente divisa in sezioni numerate:</p><ol><li>Comandi utente</li><li>Documentazione sulle chiamate di sistema</li><li>Documentazione sulle funzioni di libreria fornite dalla libreria C standard</li><li>Documentazione sui dispositivi</li><li>Formati di file e convenzioni</li></ol><p>Come ottenere la documentazione di&mldr;</p><ul><li>cd comando bash: <code>man cd</code> (o man 1 cd) open chiamata di sistema: man 2 open</li><li>funzione C strlen: <code>man 3 strlen</code></li><li>dispositivi disco fisso: <code>man 4 hd</code></li><li>formato file fstab: <code>man 5 fstab</code></li></ul><p>Utilità:
Il comando <code>man -k &lt;str></code> cerca le descrizioni brevi e i nomi delle pagine del manuale per la parola chiave str come espressione regolare.</p><footer><p>Contenuto basato sulle slide del corso di Sistemi Operativi A.A Laboratorio 2021-2022 UniVR. Copyright degli autori delle slide originali.
<a href=https://github.com/seekbytes/oslab/edit/main/content/lezioni/1_concetti_fondamentali.md>Modifica questa pagina</a></p></footer></div></body></html>