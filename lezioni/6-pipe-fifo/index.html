<!doctype html><html lang=it><head><meta charset=utf-8><meta name=author content="SeekBytes"><meta name=viewport content="width=device-width,initial-scale=1"><title>Lezione 6 - Pipe e FIFO</title><link href=https://seekbytes.github.io/oslab/css/style.css rel=stylesheet type=text/css><link href=https://seekbytes.github.io/oslab/css/syntax.css rel=stylesheet type=text/css><link href=https://seekbytes.github.io/oslab/css/print.css rel=stylesheet media=print type=text/css></head><body class=flex><div class=navbar-lat><div class=links><h2>Indice</h2><nav id=TableOfContents><ul><li><a href=#concetti-fondamentali>Concetti fondamentali</a><ul><li><a href=#creazione-e-apertura-pipe>Creazione e apertura pipe</a></li></ul></li><li><a href=#buone-pratiche>Buone pratiche</a></li><li><a href=#fifo>FIFO</a></li><li><a href=#creazione-ed-apertura-di-una-fifo>Creazione ed apertura di una FIFO</a><ul><li><a href=#open-per-le-fifo>Open per le FIFO</a></li></ul></li></ul></nav><h3>Contenuti</h3><ul><li><a href=https://seekbytes.github.io/oslab/lezioni/0-sistemi-operativi-laboratorio/>Lezione 0 - Introduzione a Sistemi Operativi Laboratorio</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/1-a-concetti-fondamentali/>Lezione 1.A - Concetti fondamentali: Processi e Programmi</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/1-b-file-system/>Lezione 1.B - Concetti fondamentali: File System</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/2-processi/>Lezione 2 - Processi</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/3-mentos/>Lezione 3.A - Fondamentali di MentOS</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/3-b-mentos-scheduling/>Lezione 3.B - MentOS Scheduling</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/4-a-semafori-ipc/>Lezione 4.A - IPC e Semafori</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/4-b-segnali-ipc/>Lezione 4.B - IPC e Segnali</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/5-memoria-condivisa-coda-di-messaggi/>Lezione 5 - Memoria condivisa e coda di messaggi</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/6-pipe-fifo/>Lezione 6 - Pipe e FIFO</a></li></ul><a href=../>Sezione principale</a></div></div><div class=content><a href=https://seekbytes.github.io/oslab/>Ritorna indietro</a><h1>Lezione 6 - Pipe e FIFO</h1><p class=details>Pubblicato il 4/5/22 da SeekBytes – 1151 parole</p><h2 id=concetti-fondamentali>Concetti fondamentali</h2><p>Una PIPE è un flusso di dati in byte che permette a processi di scambiare byte. Tecnicalmente parlando è un buffer nella memoria del kernel. Una PIPE ha le seguenti proprietà:</p><ul><li><p>è unidirezionale. I dati viaggiano solo in una direzione. Un&rsquo;estremità di una PIPE è utilizzata per scrivere, l&rsquo;altra per leggere.</p></li><li><p>i dati passano dalla PIPE in modo sequenziale. I byte sono letti da una PIPE nell&rsquo;esatto ordine in cui sono stati scritti.</p></li><li><p>nessun concetto/astrazione di messaggi. Il processo che legge da una PIPE può leggere blocchi di dati di tutti i tipi, non curandosi della dimensione dei blocchi del processo scrivente.</p></li><li><p>il tentativo di leggere da una PIPE vuota blocca il lettore finché almeno un byte è stato scritto nella PIPE oppure un segnale viene ricevuto (terminando con EINTR).</p></li><li><p>Se l&rsquo;estremità in cui si scrive è chiusa, allora un processo che legge dalla PIPe vedrà un end-of-file quando ha letto tutti i dati sulla PIPE.</p></li><li><p>Un&rsquo;operazione di scrittura è bloccata fino a quando:</p><ul><li>esiste altro spazio disponibile</li><li>un segnale viene ricevuto</li></ul></li><li><p>Operazioni di scrittura più larghi della PIPE_BUF bytes potrebbero essere divisi in segmenti di dimensioni arbitrarie</p></li></ul><h3 id=creazione-e-apertura-pipe>Creazione e apertura pipe</h3><p>La system call <code>pipe</code> crea una nuova PIPE.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// Returns 0 on success, or -1 on error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>pipe</span><span class=p>(</span><span class=kt>int</span> <span class=n>filedes</span><span class=p>[</span><span class=mi>2</span><span class=p>]);</span></span></span></code></pre></div><p>Una chiamata riuscita a pipe restituisce due descrittori di file aperti nell&rsquo;array
filedes.</p><ul><li><code>filedes[0]</code> memorizza la fine della lettura del PIPE.</li><li><code>filedes[1]</code> memorizza l&rsquo;estremità di scrittura del PIPE.
Come con qualsiasi descrittore di file, possiamo usare le chiamate di sistema read e write per eseguire I/O sul PIPE.
Normalmente, usiamo un PIPE per permettere la comunicazione tra processi correlati. Per collegare due processi usando un PIPE, seguiamo la chiamata pipe con una chiamata a <code>fork</code>.</li></ul><details><summary><b>Creazione di una PIPE - esempio 1</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=n>fd</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=c1>// checking if PIPE successed
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>pipe</span><span class=p>(</span><span class=n>fd</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>errExit</span><span class=p>(</span><span class=s>&#34;PIPE&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// Create a child process
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>switch</span><span class=p>(</span><span class=n>fork</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=o>-</span><span class=mi>1</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=n>errExit</span><span class=p>(</span><span class=s>&#34;fork&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=mi>0</span><span class=o>:</span> <span class=c1>// Child
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>//...child reads from PIPE
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>default</span><span class=o>:</span> <span class=c1>// Parent
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>//...parent writes to PIPE
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><ol><li><p>Pipe crea una nuova PIPE. fd[0] è l&rsquo;estremità per la lettura, f[1] è l&rsquo;estremità per la scrittura.</p></li><li><p><code>fork()</code> crea un processo figlio che eredita la file descriptor table dal processo genitore.</p></li></ol><h4>Processo figlio</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=n>SIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=n>ssize_t</span> <span class=n>nBys</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// close unused write-end
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>close</span><span class=p>(</span><span class=n>fd</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>errExit</span><span class=p>(</span><span class=s>&#34;close - child&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// reading from the PIPE
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>nBys</span> <span class=o>=</span> <span class=n>read</span><span class=p>(</span><span class=n>fd</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>buf</span><span class=p>,</span> <span class=n>SIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// 0: end-of-file, -1: failure
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>nBys</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>buf</span><span class=p>[</span><span class=n>nBys</span><span class=p>]</span> <span class=o>=</span> <span class=err>’\</span><span class=mi>0</span><span class=err>’</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>printf</span><span class=p>(</span><span class=s>&#34;%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>buf</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// close read-end of PIPE
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>close</span><span class=p>(</span><span class=n>fd</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>errExit</span><span class=p>(</span><span class=s>&#34;close - child&#34;</span><span class=p>);</span></span></span></code></pre></div><h4>Processo parent</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>char</span> <span class=n>buf</span><span class=p>[]</span> <span class=o>=</span> <span class=s>&#34;Ciao Mondo</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>ssize_t</span> <span class=n>nBys</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// close unused read-end
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>close</span><span class=p>(</span><span class=n>fd</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>errExit</span><span class=p>(</span><span class=s>&#34;close - parent&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// write to the PIPE
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>nBys</span> <span class=o>=</span> <span class=n>write</span><span class=p>(</span><span class=n>fd</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>buf</span><span class=p>,</span> <span class=n>strlen</span><span class=p>(</span><span class=n>buf</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=c1>// checkig if write successed
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>nBys</span> <span class=o>!=</span> <span class=n>strlen</span><span class=p>(</span><span class=n>buf</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>errExit</span><span class=p>(</span><span class=s>&#34;write - parent&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// close write-end of PIPE
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>close</span><span class=p>(</span><span class=n>fd</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>errExit</span><span class=p>(</span><span class=s>&#34;close - child&#34;</span><span class=p>);</span></span></span></code></pre></div></details><h2 id=buone-pratiche>Buone pratiche</h2><p>Perché dovremo chiudere i file descriptor non utilizzzati? Che problema potremo avere?</p><details><summary><b>Esempio su come utilizzare le PIPE IN MODO SBAGLIATO 1</b></summary><p>Processo figlio:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// close unused write-end
</span></span></span><span class=line><span class=cl><span class=c1>//if (close(fd[1]) == -1)
</span></span></span><span class=line><span class=cl><span class=c1>// errExit(&#34;close - child&#34;);
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=n>SIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=n>ssize_t</span> <span class=n>nBys</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// reading from the PIPE
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>nBys</span> <span class=o>=</span> <span class=n>read</span><span class=p>(</span><span class=n>fd</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>buf</span><span class=p>,</span> <span class=n>SIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// 0: end-of-file, -1: failure
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>nBys</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>printf</span><span class=p>(</span><span class=s>&#34;%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>buf</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// close read-end of PIPE
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>close</span><span class=p>(</span><span class=n>fd</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>errExit</span><span class=p>(</span><span class=s>&#34;close - child&#34;</span><span class=p>);</span></span></span></code></pre></div><p>Processo padre:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// close unused read-end
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>close</span><span class=p>(</span><span class=n>fd</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>errExit</span><span class=p>(</span><span class=s>&#34;close - parent&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// ...nothing to send
</span></span></span><span class=line><span class=cl><span class=c1>// close write-end of PIPE
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>close</span><span class=p>(</span><span class=n>fd</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>errExit</span><span class=p>(</span><span class=s>&#34;close - child&#34;</span><span class=p>);</span></span></span></code></pre></div><p>Perché questo programma è sbagliato? Il processo in lettura sta aspettando dati.</p></details><details><summary><b>Esempio su come utilizzare le PIPE IN MODO SBAGLIATO 2</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// close unused write-end
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>close</span><span class=p>(</span><span class=n>fd</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>errExit</span><span class=p>(</span><span class=s>&#34;close - child&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// ...nothing to read
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// close read-end of PIPE
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>close</span><span class=p>(</span><span class=n>fd</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>errExit</span><span class=p>(</span><span class=s>&#34;close - child&#34;</span><span class=p>);</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// close unused read-end
</span></span></span><span class=line><span class=cl><span class=c1>//if (close(fd[0]) == -1)
</span></span></span><span class=line><span class=cl><span class=c1>// errExit(&#34;close - parent&#34;);
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>char</span> <span class=n>buf</span><span class=p>[]</span> <span class=o>=</span> <span class=s>&#34;Ciao Mondo</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>size_t</span> <span class=n>len</span> <span class=o>=</span> <span class=n>strlen</span><span class=p>(</span><span class=n>buf</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// write to the PIPE
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>nBys</span> <span class=o>=</span> <span class=n>write</span><span class=p>(</span><span class=n>fd</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>buf</span><span class=p>,</span> <span class=n>len</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// checkig if write successed
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>nBys</span> <span class=o>!=</span> <span class=n>len</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>errExit</span><span class=p>(</span><span class=s>&#34;write - parent&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// close write-end of PIPE
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>close</span><span class=p>(</span><span class=n>fd</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>errExit</span><span class=p>(</span><span class=s>&#34;close - child&#34;</span><span class=p>);</span></span></span></code></pre></div><p>Perché questo programma è sbagliato? Il programma che scrive a chi sta inviando i dati?</p></details><h2 id=fifo>FIFO</h2><p>Una FIFO è un flusso di byte che permette ai processi di scambiare informazioni. Tecnicalmente parlando è un buffer nella memoria del kernel. Semanticamente, una FIFO è simile ad una PIPE.</p><p>La principale differenza tra una PIPE e una FIFO è che la FIFO ha un nome all&rsquo;interno del file system, è aperta ed eliminata allo stesso modo di un file. Questo consente ad una FIFO di essere utilizzata per la comunicazione <strong>tra processi che non condividono alcuna relazione</strong>.</p><p>Come le PIPE, anche le FIFO hanno un&rsquo;estremità per leggere e per scrivere, i dati sono letti dalle FIFO nello stesso ordine in cui sono stati scritti.</p><h2 id=creazione-ed-apertura-di-una-fifo>Creazione ed apertura di una FIFO</h2><p>La system call <code>mkfifo</code> crea una nuova FIFO.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// Returns 0 on success, or -1 on error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>mkfifo</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>pathname</span><span class=p>,</span> <span class=n>mode_t</span> <span class=n>mode</span><span class=p>);</span></span></span></code></pre></div><p>Il parametro pathname specifica dove la FIFO è aperta. Come per un normale file, il parametro mode specifica i permessi della FIFO (vedi <a href=/lezioni/1-b-file-system/>prima lezione</a>). Una volta che la FIFO è stata creata, qualsiasi processo può aprirla.</p><h3 id=open-per-le-fifo>Open per le FIFO</h3><p>La system call open apre una FIFO.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// Returns file descriptor on success, or -1 on error.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>open</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>pathname</span><span class=p>,</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>);</span></span></span></code></pre></div><p>Il parametro <code>pathname</code> specifica la posizione del FIFO nel file system. L&rsquo;argomento <code>flags</code> è una maschera di bit di una delle seguenti costanti che specificano la modalità di accesso per il FIFO.</p><table><thead><tr><th>Flag</th><th>Descrizione</th></tr></thead><tbody><tr><td><code>O_RDONLY</code></td><td>Apre in sola lettura</td></tr><tr><td><code>O_WRONLY</code></td><td>Apre in sola scrittura</td></tr></tbody></table><p>L&rsquo;unico uso sensato di un FIFO è quello di avere un processo di lettura e uno di scrittura su ogni estremità. Per impostazione predefinita, l&rsquo;apertura di una FIFO per la lettura (flag <code>O_RDONLY</code>) blocca finché un altro processo non apre la FIFO per la scrittura (flag <code>O_WRONLY</code>). Al contrario, l&rsquo;apertura del FIFO per la scrittura blocca finché un altro processo apre la FIFO per la lettura. In altre parole, l&rsquo;apertura di una FIFO sincronizza i processi di lettura e scrittura. Se l&rsquo;estremità opposta di una FIFO è già aperta (forse perché una coppia di processi ha già aperto ciascuna estremità della FIFO), allora l&rsquo;apertura ha successo immediatamente.</p><details><summary><b>Esempio FIFO e sincronizzazione</b></summary><h4>Receiver</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>char</span> <span class=o>*</span><span class=n>fname</span> <span class=o>=</span> <span class=s>&#34;/tmp/myfifo&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>res</span> <span class=o>=</span> <span class=n>mkfifo</span><span class=p>(</span><span class=n>fname</span><span class=p>,</span> <span class=n>S_IRUSR</span><span class=o>|</span><span class=n>S_IWUSR</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// Opening for reading only
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>fd</span> <span class=o>=</span> <span class=n>open</span><span class=p>(</span><span class=n>fname</span><span class=p>,</span> <span class=n>O_RDONLY</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// reading bytes from fifo
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>char</span> <span class=n>buffer</span><span class=p>[</span><span class=n>LEN</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=n>read</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>buffer</span><span class=p>,</span> <span class=n>LEN</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// Printing buffer on stdout
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>printf</span><span class=p>(</span><span class=s>&#34;%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>buffer</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// closing the fifo
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>close</span><span class=p>(</span><span class=n>fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// Removing FIFO
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>unlink</span><span class=p>(</span><span class=n>fname</span><span class=p>);</span></span></span></code></pre></div><h4>Sender</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>char</span> <span class=o>*</span><span class=n>fname</span> <span class=o>=</span> <span class=s>&#34;/tmp/myfifo&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// Opening for wringing only
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>fd</span> <span class=o>=</span> <span class=n>open</span><span class=p>(</span><span class=n>fname</span><span class=p>,</span> <span class=n>O_WRONLY</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>//reading a str. (no spaces)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>char</span> <span class=n>buffer</span><span class=p>[</span><span class=n>LEN</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=n>printf</span><span class=p>(</span><span class=s>&#34;Give me a string: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>scanf</span><span class=p>(</span><span class=s>&#34;%s&#34;</span><span class=p>,</span> <span class=n>buffer</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// writing the string on fifo
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>write</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>buffer</span><span class=p>,</span> <span class=n>strlen</span><span class=p>(</span><span class=n>buffer</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=c1>// closing the fifo
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>close</span><span class=p>(</span><span class=n>fd</span><span class=p>);</span></span></span></code></pre></div></details><footer><p>Contenuto basato sulle slide del corso di Sistemi Operativi A.A Laboratorio 2021-2022 UniVR. Copyright degli autori delle slide originali.
<a href=https://github.com/seekbytes/oslab/edit/main/content/lezioni/6_FIFO.md>Modifica questa pagina</a></p></footer></div></body></html>