<!doctype html><html lang=it><head><meta charset=utf-8><meta name=author content="SeekBytes"><meta name=viewport content="width=device-width,initial-scale=1"><title>Lezione 5 - Memoria condivisa e coda di messaggi</title><link href=https://seekbytes.github.io/oslab/css/style.css rel=stylesheet type=text/css><link href=https://seekbytes.github.io/oslab/css/syntax.css rel=stylesheet type=text/css><link href=https://seekbytes.github.io/oslab/css/print.css rel=stylesheet media=print type=text/css><meta name=description content="Utilizzo della memoria condivisa tra i processi e introduzione alla coda di messaggi."></head><body class=flex><div class=navbar-lat><div class=links><h2>Indice</h2><nav id=TableOfContents><ul><li><a href=#memoria-condivisa>Memoria condivisa</a><ul><li><a href=#concetti-fondamentali>Concetti fondamentali</a></li><li><a href=#creazione-ed-apertura-shmget>Creazione ed apertura (shmget)</a></li><li><a href=#attaccare-un-segmento-shmat>Attaccare un segmento (shmat)</a></li><li><a href=#staccare-il-segmento-shmdt>Staccare il segmento (shmdt)</a></li><li><a href=#shmctl>shmctl</a><ul><li><a href=#operazioni-di-controllo>Operazioni di controllo</a></li></ul></li></ul></li><li><a href=#coda-messaggi>Coda messaggi</a><ul><li><a href=#creazione-e-apertura>Creazione e apertura</a></li><li><a href=#struttura-dei-messaggi>Struttura dei messaggi</a></li><li><a href=#inviare-un-messaggio-msgsnd>Inviare un messaggio (msgsnd)</a></li><li><a href=#ricevere-un-messaggio-msgrcv>Ricevere un messaggio (msgrcv)</a></li><li><a href=#operazioni-di-controllo-msgctl>Operazioni di controllo msgctl</a></li><li><a href=#struttura-msqid_ds>Struttura msqid_ds</a></li></ul></li><li><a href=#visione-conclusiva-delle-interfacce-system-v>Visione conclusiva delle interfacce System V</a></li></ul></nav><h3>Contenuti</h3><ul><li><a href=https://seekbytes.github.io/oslab/lezioni/0-sistemi-operativi-laboratorio/>Lezione 0 - Introduzione a Sistemi Operativi Laboratorio</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/1-a-concetti-fondamentali/>Lezione 1.A - Concetti fondamentali: Processi e Programmi</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/1-b-file-system/>Lezione 1.B - Concetti fondamentali: File System</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/2-processi/>Lezione 2 - Processi</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/3-mentos/>Lezione 3.A - Fondamentali di MentOS</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/3-b-mentos-scheduling/>Lezione 3.B - MentOS Scheduling</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/4-a-semafori-ipc/>Lezione 4.A - IPC e Semafori</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/4-b-segnali-ipc/>Lezione 4.B - IPC e Segnali</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/5-memoria-condivisa-coda-di-messaggi/>Lezione 5 - Memoria condivisa e coda di messaggi</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/6-pipe-fifo/>Lezione 6 - Pipe e FIFO</a></li></ul><a href=../>Sezione principale</a></div></div><div class=content><a href=https://seekbytes.github.io/oslab/>Ritorna indietro</a><h1>Lezione 5 - Memoria condivisa e coda di messaggi</h1><p class=details>Pubblicato il 3/29/22 da SeekBytes – 2612 parole</p><h2 id=memoria-condivisa>Memoria condivisa</h2><h3 id=concetti-fondamentali>Concetti fondamentali</h3><p>Una memoria condivisa è un segmento di memoria fisica gestito dal Kernel, che permette a due o più processi di scambiarsi dati. Una volta collegata, anche più di una volta, la memoria condivisa fa parte dello spazio di indirizzamento virtuale del processo, e non è richiesto alcun intervento del kernel. I dati scritti in una memoria condivisa sono immediatamente disponibili a tutti gli altri processo che condividono lo stesso segmento. Tipicamente, qualche metodo di sincronizzazione è richiesto in modo che i processi non accedano simultaneamente accedere alla memoria condivisa (per esempio, semafori!).</p><h3 id=creazione-ed-apertura-shmget>Creazione ed apertura (shmget)</h3><p>La chiamata di sistema shmget crea un nuovo segmento di memoria condivisa o ottiene l&rsquo;identificatore di uno esistente. Il contenuto di un segmento di memoria condivisa appena creato è inizializzato a 0.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/shm.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// Returns a shared memory segment identifier on success, or -1 on error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>shmget</span><span class=p>(</span><span class=n>key_t</span> <span class=n>key</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>size</span><span class=p>,</span> <span class=kt>int</span> <span class=n>shmflg</span><span class=p>);</span></span></span></code></pre></div><p>Gli argomenti chiave sono:</p><ul><li>una chiave IPC.</li><li><code>size</code> specifica la dimensione desiderata 1 del segmento, in byte.</li><li>se stiamo usando shmget per ottenere l&rsquo;identificatore di un segmento esistente, allora la dimensione non ha effetto sul segmento, ma deve essere minore o
uguale alla dimensione del segmento.</li></ul><p><code>shmflg</code> è una maschera di bit che specifica i permessi (vedere la chiamata di sistema <code>open(...)</code> di sistema, argomento mode) da porre su un nuovo segmento di memoria condivisa o controllati su un segmento esistente. In aggiunta, i seguenti flag possono essere ORed (|) in shmflg:</p><ul><li><code>IPC_CREAT</code>: se non esiste alcun segmento con la chiave specificata, crea un nuovo segmento</li><li><code>IPC_EXCL</code>: in combinazione con <code>IPC_CREAT</code>, fa fallire shmget se un segmento esiste con la chiave specificata.</li></ul><details><summary><b>Esempio di creazione di un segmento di memoria condiviso</b></summary>
int shmid;
ket_t key = //&mldr; (generate a key in some way, i.e. with ftok)
size_t size = //&mldr; (compute size value in some way)
// A) delegate the problem of finding a unique key to the kernel
shmid = shmget(IPC_PRIVATE, size, S_IRUSR | S_IWUSR);
// B) create a shared memory with identifier key, if it doesn’t already exist
shmid = shmget(key, size, IPC_CREAT | S_IRUSR | S_IWUSR);
// C) create a shared memory with identifier key, but fail if it exists already
shmid = shmget(key, size, IPC_CREAT | IPC_EXCL | S_IRUSR | S_IWUSR);</details><h3 id=attaccare-un-segmento-shmat>Attaccare un segmento (shmat)</h3><p>La chiamata di sistema shmat attacca il segmento di memoria condivisa identificato da shmid allo spazio degli indirizzi virtuali del processo chiamante.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/shm.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// Returns address at which shared memory is attached on success
</span></span></span><span class=line><span class=cl><span class=c1>// or (void *)-1 on error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=o>*</span><span class=nf>shmat</span><span class=p>(</span><span class=kt>int</span> <span class=n>shmid</span><span class=p>,</span> <span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=n>shmaddr</span><span class=p>,</span> <span class=kt>int</span> <span class=n>shmflg</span><span class=p>);</span></span></span></code></pre></div><ul><li><code>shmaddr NULL</code>: il segmento è attaccato ad un indirizzo adatto selezionato dal kernel (<code>shmaddr</code> e <code>shmflg</code> sono ignorati)</li><li><code>shmaddr</code> non <code>NULL</code>: il segmento è attaccato all&rsquo;indirizzo shmaddr</li><li><code>shmflg SHM_RND</code>: shmaddr viene arrotondato per difetto al più vicino multiplo di della costante SHMLBA (indirizzo di confine basso della memoria condivisa)</li></ul><p>Normalmente, shmaddr è NULL, per le seguenti ragioni:</p><ul><li>Aumenta la portabilità di un&rsquo;applicazione. Un indirizzo valido su un&rsquo;implementazione UNIX può essere non valido su un&rsquo;altra.</li><li>Un tentativo di collegare un segmento di memoria condivisa ad un particolare indirizzo fallirà se quell&rsquo;indirizzo è già in uso.
In aggiunta a <code>SHM_RND</code>, la flag <code>SHM_RDONLY</code> può essere specificato per allegare una memoria condivisa per la sola lettura. Se shmflg ha valore zero, la memoria condivisa è collegata in modalità lettura e scrittura.</li></ul><p>Un processo figlio eredita i segmenti di memoria condivisa del suo genitore. La memoria condivisa fornisce un facile metodo di IPC tra genitore e figlio!</p><details><summary><b>Esempio di come attaccare un segmento di memoria condivisa</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// attach the shared memory in read/write mode
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=o>*</span><span class=n>ptr_1</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=p>)</span><span class=n>shmat</span><span class=p>(</span><span class=n>shmid</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// attach the shared memory in read only mode
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=o>*</span><span class=n>ptr_2</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=p>)</span><span class=n>shmat</span><span class=p>(</span><span class=n>shmid</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>SHM_RDONLY</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// N.B. ptr_1 and ptr_2 are different!
</span></span></span><span class=line><span class=cl><span class=c1>// But they refer to the same shared memory!
</span></span></span><span class=line><span class=cl><span class=c1>// write 10 integers to shared memory segment
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>ptr_1</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// read 10 integers from shared memory segment
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>printf</span><span class=p>(</span><span class=s>&#34;integer: %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>ptr_2</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span></span></span></code></pre></div><p>Che cosa stamperà il programma? Possiamo utilizzare <code>ptr_2</code> per scrivere sul segmento della memoria? (Spoiler: no).</p></details><h3 id=staccare-il-segmento-shmdt>Staccare il segmento (shmdt)</h3><p>Quando un processo non ha più bisogno di accedere ad un segmento di memoria condivisa, può chiamare shmdt per staccare il segmento dal suo spazio di indirizzo virtuale. L&rsquo;argomento shmaddr identifica il segmento da staccare, ed è un valore restituito da una precedente chiamata a shmat.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/shm.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// Returns 0 on success, or -1 on error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>shmdt</span><span class=p>(</span><span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=n>shmaddr</span><span class=p>);</span></span></span></code></pre></div><p>Durante un exec, tutti i segmenti di memoria condivisa collegati sono staccati. I segmenti di memoria condivisa sono anche distaccati automaticamente alla terminare.</p><details><summary><b>Esempio di come staccare un segmento di memoria condivisa</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// attach the shared memory in read/write mode
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=o>*</span><span class=n>ptr_1</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=p>)</span><span class=n>shmat</span><span class=p>(</span><span class=n>shmid</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>ptr_1</span> <span class=o>==</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>errExit</span><span class=p>(</span><span class=s>&#34;first shmat failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// attach the shared memory in read only mode
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=o>*</span><span class=n>ptr_2</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=p>)</span><span class=n>shmat</span><span class=p>(</span><span class=n>shmid</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>SHM_RDONLY</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>ptr_2</span> <span class=o>==</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>errExit</span><span class=p>(</span><span class=s>&#34;second shmat failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>//...
</span></span></span><span class=line><span class=cl><span class=c1>// detach the shared memory segments
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>shmdt</span><span class=p>(</span><span class=n>ptr_1</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span> <span class=o>||</span> <span class=n>shmdt</span><span class=p>(</span><span class=n>ptr_2</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>errExit</span><span class=p>(</span><span class=s>&#34;shmdt failed&#34;</span><span class=p>);</span></span></span></code></pre></div></details><h3 id=shmctl>shmctl</h3><p>La chiamata di sistema shmctl esegue operazioni di controllo su un segmento di memoria condivisa.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/msg.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// Returns 0 on success, or -1 error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>shmctl</span><span class=p>(</span><span class=kt>int</span> <span class=n>shmid</span><span class=p>,</span> <span class=kt>int</span> <span class=n>cmd</span><span class=p>,</span> <span class=k>struct</span> <span class=n>shmid_ds</span> <span class=o>*</span><span class=n>buf</span><span class=p>);</span></span></span></code></pre></div><p>L&rsquo;argomento shmid è un identificatore di memoria condivisa. L&rsquo;argomento cmd specifica l&rsquo;operazione da eseguire sulla memoria condivisa:</p><ul><li><code>IPC_RMID</code>: Segna per la cancellazione la memoria condivisa. Il segmento viene rimosso non appena tutti i processi si sono staccati da esso</li><li><code>IPC_STAT</code>: posiziona una copia della struttura dati shmid ds associata a questa memoria condivisa nel buffer indicato da buf</li><li><code>IPC_SET</code>: Aggiorna i campi selezionati della struttura dati shmid ds associata a questa memoria condivisa utilizzando i valori forniti nel buffer indicato da buf.</li></ul><details><summary><b>Rimuovere un segmento di memoria condivisa</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>shmctl</span><span class=p>(</span><span class=n>shmid</span><span class=p>,</span> <span class=n>IPC_RMID</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>errExit</span><span class=p>(</span><span class=s>&#34;shmctl failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>else</span>
</span></span><span class=line><span class=cl>	<span class=nf>printf</span><span class=p>(</span><span class=s>&#34;shared memory segment removed successfully</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span></span></span></code></pre></div></details><h4 id=operazioni-di-controllo>Operazioni di controllo</h4><p>Per ogni segmento di memoria condivisa il kernel ha una struttura dati associata s<code>hmid_ds</code> della seguente forma:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>shmid_ds</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>ipc_perm</span> <span class=n>shm_perm</span><span class=p>;</span> <span class=cm>/* Ownership and permissions */</span>
</span></span><span class=line><span class=cl>	<span class=n>size_t</span> <span class=n>shm_segsz</span><span class=p>;</span> <span class=cm>/* Size of segment in bytes */</span>
</span></span><span class=line><span class=cl>	<span class=n>time_t</span> <span class=n>shm_atime</span><span class=p>;</span> <span class=cm>/* Time of last shmat() */</span>
</span></span><span class=line><span class=cl>	<span class=n>time_t</span> <span class=n>shm_dtime</span><span class=p>;</span> <span class=cm>/* Time of last shmdt() */</span>
</span></span><span class=line><span class=cl>	<span class=n>time_t</span> <span class=n>shm_ctime</span><span class=p>;</span> <span class=cm>/* Time of last change */</span>
</span></span><span class=line><span class=cl>	<span class=n>pid_t</span> <span class=n>shm_cpid</span><span class=p>;</span> <span class=cm>/* PID of creator */</span>
</span></span><span class=line><span class=cl>	<span class=n>pid_t</span> <span class=n>shm_lpid</span><span class=p>;</span> <span class=cm>/* PID of last shmat() / shmdt() */</span>
</span></span><span class=line><span class=cl>	<span class=n>shmatt_t</span> <span class=n>shm_nattch</span><span class=p>;</span> <span class=c1>// Number of currently attached
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span> <span class=c1>// processes
</span></span></span></code></pre></div><p>Con <code>IPC_STAT</code> e <code>IPC_SET</code> possiamo rispettivamente ottenere e aggiornare questa struttura di dati.</p><h2 id=coda-messaggi>Coda messaggi</h2><h3 id=creazione-e-apertura>Creazione e apertura</h3><p>La system call <code>msgget</code> crea una coda di messaggi oppure ottiene l&rsquo;identificatore di una coda già esistente.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/msg.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// Returns message queue identifier on success, or -1 error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>msgget</span><span class=p>(</span><span class=n>key_t</span> <span class=n>key</span><span class=p>,</span> <span class=kt>int</span> <span class=n>msgflg</span><span class=p>);</span></span></span></code></pre></div><p>L&rsquo;argomento <code>key</code> è una chiave IPC, msgflg è una maschera di bit che specifica i permessi (vedi la chiamata di sistema open(&mldr;), argomento mode) da inserire in una nuova coda di messaggi, o da controllare in una coda esistente. In aggiunta, i seguenti flag possono essere ORed (|) in msgflg:</p><ul><li><code>IPC_CREAT</code>: se non esiste una coda di messaggi con la chiave specificata, crea una nuova coda</li><li><code>IPC_EXCL</code>: in combinazione con <code>IPC_CREAT</code>, fa fallire msgget se esiste una coda con la chiave specificata</li></ul><details><summary><b>Esempio per creare una coda di messaggi</b></summary>
int msqid;
ket_t key = //&mldr; (generate a key in some way, i.e. with ftok)
// A) delegate the problem of finding a unique key to the kernel
msqid = msgget(IPC_PRIVATE, S_IRUSR | S_IWUSR);
// B) create a queue with identifier key, if it doesn’t already exist
msqid = msgget(key, IPC_CREAT | S_IRUSR | S_IWUSR);
// C) create a queue with identifier key, but fail if it exists already
msqid = msgget(key, IPC_CREAT | IPC_EXCL | S_IRUSR | S_IWUSR);</details><h3 id=struttura-dei-messaggi>Struttura dei messaggi</h3><p>Un messaggio in una coda di messaggi segue sempre la seguente struttura:<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>mymsg</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>long</span> <span class=n>mtype</span><span class=p>;</span> <span class=cm>/* Tipo di messaggio */</span>
</span></span><span class=line><span class=cl>	<span class=kt>char</span> <span class=n>mtext</span><span class=p>[];</span> <span class=cm>/* corpo del messaggio */</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></div></p><p>La prima parte di un messaggio contiene il tipo di messaggio, specificato come un intero lungo maggiore di 0. Il resto del messaggio è una struttura definita dal programmatore di lunghezza e contenuto arbitrari (non è necessariamente un array di char). Infatti, può essere omesso se non è necessario.</p><h3 id=inviare-un-messaggio-msgsnd>Inviare un messaggio (msgsnd)</h3><p>La chiamata di sistema msgsnd scrive un messaggio in una coda di messaggi.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/msg.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// Returns 0 on success, or -1 error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>msgsnd</span><span class=p>(</span><span class=kt>int</span> <span class=n>msqid</span><span class=p>,</span> <span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=n>msgp</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>msgsz</span><span class=p>,</span> <span class=kt>int</span> <span class=n>msgflg</span><span class=p>);</span></span></span></code></pre></div><ul><li>l&rsquo;argomento msqid è un identificatore di coda di messaggi</li><li>msgp è un indirizzo che punta a una struttura di messaggio</li><li>msgsz specifica il numero di byte contenuti nel campo mtext di del messaggio</li><li>l&rsquo;argomento msgflg può essere 0, o il flag IPC NOWAIT.<ul><li>Normalmente, se una coda di messaggi è piena, msgsnd si blocca fino a quando non diventa disponibile abbastanza spazio per permettere al messaggio di essere messo in coda. Se viene specificato <code>IPC_NOWAIT</code>, <code>msgsnd</code> ritorna immediatamente con l&rsquo;errore <code>EAGAIN</code> (cioè, non ci sono dati disponibili in questo momento, riprova più tardi).</li></ul></li></ul><details><summary><b>Esempio di invio messaggio</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// Message structure
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>mymsg</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>long</span> <span class=n>mtype</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>char</span> <span class=n>mtext</span><span class=p>[</span><span class=mi>100</span><span class=p>];</span> <span class=cm>/* array of chars as message body */</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>m</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// message has type 1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>m</span><span class=p>.</span><span class=n>mtype</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// message contains the following string
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>char</span> <span class=o>*</span><span class=n>text</span> <span class=o>=</span> <span class=s>&#34;Ciao mondo!&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>memcpy</span><span class=p>(</span><span class=n>m</span><span class=p>.</span><span class=n>mtext</span><span class=p>,</span> <span class=n>text</span><span class=p>,</span> <span class=n>strlen</span><span class=p>(</span><span class=n>text</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span> <span class=c1>// why +1 here?
</span></span></span><span class=line><span class=cl><span class=c1>// size of m is only the size of its mtext attribute!
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>size_t</span> <span class=n>mSize</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>mymsg</span><span class=p>)</span> <span class=o>-</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>long</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// sending the message in the queue
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>msgsnd</span><span class=p>(</span><span class=n>msqid</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>m</span><span class=p>,</span> <span class=n>mSize</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>errExit</span><span class=p>(</span><span class=s>&#34;msgsnd failed&#34;</span><span class=p>);</span></span></span></code></pre></div></details><details><summary><b>Esempio di invio messaggio 2</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// Message structure
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>mymsg</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>long</span> <span class=n>mtype</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>num1</span><span class=p>,</span> <span class=n>num2</span><span class=p>;</span> <span class=cm>/* two integers as message body */</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>m</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// message has type 2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>m</span><span class=p>.</span><span class=n>mtype</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// message contains the following numbers
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>m</span><span class=p>.</span><span class=n>num1</span> <span class=o>=</span> <span class=mi>34</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>m</span><span class=p>.</span><span class=n>num2</span> <span class=o>=</span> <span class=mi>43</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// size of m is only the size of its mtext attribute!
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>size_t</span> <span class=n>mSize</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>mymsg</span><span class=p>)</span> <span class=o>-</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>long</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// sending the message in the queue
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>msgsnd</span><span class=p>(</span><span class=n>msqid</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>m</span><span class=p>,</span> <span class=n>mSize</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>errExit</span><span class=p>(</span><span class=s>&#34;msgsnd failed&#34;</span><span class=p>);</span></span></span></code></pre></div></details><details><summary><b>Esempio di invio messaggio senza body</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// Message structure
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>mymsg</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>long</span> <span class=n>mtype</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=cm>/* The message has not got body. It has just a type!*/</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>m</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// message has type 3
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>m</span><span class=p>.</span><span class=n>mtype</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// size of m is only the size of its mtext attribute!
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>size_t</span> <span class=n>mSize</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>mymsg</span><span class=p>)</span> <span class=o>-</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>long</span><span class=p>);</span> <span class=c1>// 0!
</span></span></span><span class=line><span class=cl><span class=c1>// sending the message in the queue
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>msgsnd</span><span class=p>(</span><span class=n>msqid</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>m</span><span class=p>,</span> <span class=n>mSize</span><span class=p>,</span> <span class=n>IPC_NOWAIT</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>errno</span> <span class=o>==</span> <span class=n>EAGAIN</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=n>printf</span><span class=p>(</span><span class=s>&#34;The queue was full!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=n>errExit</span><span class=p>(</span><span class=s>&#34;msgsnd failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></details><h3 id=ricevere-un-messaggio-msgrcv>Ricevere un messaggio (msgrcv)</h3><p>La chiamata di sistema <code>msgrcv</code> legge e rimuove un messaggio da una coda.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/msg.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// Returns number of bytes copied into msgp on success, or -1 error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>ssize_t</span> <span class=nf>msgrcv</span><span class=p>(</span><span class=kt>int</span> <span class=n>msqid</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>msgp</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>msgsz</span><span class=p>,</span> <span class=kt>long</span> <span class=n>msgtype</span><span class=p>,</span> <span class=kt>int</span> <span class=n>msgflg</span><span class=p>);</span></span></span></code></pre></div><p>L&rsquo;argomento <code>msqid</code> è un identificatore di coda di messaggi. Lo spazio massimo disponibile nel campo mtext del buffer msgp è specificato dall&rsquo;argomento msgsz.</p><p>Il valore nel campo <code>msgtype</code> seleziona il messaggio recuperato come segue:</p><ul><li>se uguale a 0, il primo messaggio dalla coda viene rimosso e restituito al processo chiamante.</li><li>se maggiore di 0, il primo messaggio dalla coda che ha mtype uguale a msgtype viene rimosso e restituito al processo chiamante.</li><li>se inferiore a 0, il primo messaggio del tipo m più basso inferiore o uguale al valore assoluto di msgtype viene rimosso e restituito al processo chiamante.</li></ul><p>Data la definizione del messaggio: (mtype, char) e la seguente coda:
{(300,&lsquo;a&rsquo;); (100,&lsquo;b&rsquo;); (200,&lsquo;c&rsquo;); (400,&rsquo;d&rsquo;); (100,&rsquo;e&rsquo;)}
Una serie di chiamate msgrcv con msgtype=-300 recupera i messaggi:
(100,&lsquo;b&rsquo;), (100,&rsquo;e&rsquo;), (200,&lsquo;c&rsquo;), (300,&lsquo;a&rsquo;)</p><p>L&rsquo;argomento msgflg è una maschera di bit formata da OR insieme a zero o più dei seguenti flag:</p><ul><li><code>IPC_NOWAIT</code>: Per impostazione predefinita, se nessun messaggio corrispondente a msgtype è nella coda, msgrcv si blocca fino a quando un tale messaggio diventa disponibile. Specificando il flag <code>IPC_NOWAIT</code>, msgrcv ritorna immediatamente con l&rsquo;errore ENOMSG.</li><li><code>MSG_NOERROR</code>: Per default, se la dimensione del campo mtext del messaggio supera lo spazio disponibile (come definito dall&rsquo;argomento msgsz), msgrcv fallisce. Se viene specificato il flag <code>MSG_NOERROR</code>, allora msgrcv rimuove invece il messaggio dalla coda, tronca il suo campo mtext a msgsz bytes, e lo restituisce al chiamante.</li></ul><details><summary><b>Esempio 1</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// message structure definition
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>mymsg</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>long</span> <span class=n>mtype</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>char</span> <span class=n>mtext</span><span class=p>[</span><span class=mi>100</span><span class=p>];</span> <span class=cm>/* array of chars as message body */</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>m</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// Get the size of the mtext field.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>size_t</span> <span class=n>mSize</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>mymsg</span><span class=p>)</span> <span class=o>-</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>long</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// Wait for a message having type equals to 1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>msgrcv</span><span class=p>(</span><span class=n>msqid</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>m</span><span class=p>,</span> <span class=n>mSize</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>errExit</span><span class=p>(</span><span class=s>&#34;msgrcv failed&#34;</span><span class=p>);</span></span></span></code></pre></div></details><details><summary><b>Esempio 2</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// message structure definition
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>mymsg</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>long</span> <span class=n>mtype</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>char</span> <span class=n>mtext</span><span class=p>[</span><span class=mi>100</span><span class=p>];</span> <span class=cm>/* array of chars as message body */</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>m</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// Set an arbitrary size for the size.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>size_t</span> <span class=n>mSize</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>char</span><span class=p>)</span> <span class=o>*</span> <span class=mi>50</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// Wait for a message having type equals to 1, but copy its first 50 bytes only
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>msgrcv</span><span class=p>(</span><span class=n>msqid</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>m</span><span class=p>,</span> <span class=n>mSize</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=n>MSG_NOERROR</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>errExit</span><span class=p>(</span><span class=s>&#34;msgrcv failed&#34;</span><span class=p>);</span></span></span></code></pre></div></details><details><summary><b>Esempio 3</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// Message structure
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>mymsg</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>long</span> <span class=n>mtype</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>m</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// In polling mode, try to get a message every SEC seconds.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>sleep</span><span class=p>(</span><span class=n>SEC</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Performing a nonblocking msgrcv.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=p>(</span><span class=n>msgrcv</span><span class=p>(</span><span class=n>msqid</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>m</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=n>IPC_NOWAIT</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=n>errno</span> <span class=o>==</span> <span class=n>ENOMSG</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=n>printf</span><span class=p>(</span><span class=s>&#34;No message with type 3 in the queue</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=n>errExit</span><span class=p>(</span><span class=s>&#34;msgrcv failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>printf</span><span class=p>(</span><span class=s>&#34;I found a message with type 3</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></details><h3 id=operazioni-di-controllo-msgctl>Operazioni di controllo msgctl</h3><p>La chiamata di sistema msgctl esegue operazioni di controllo sulla coda dei messaggi.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/msg.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// Returns 0 on success, or -1 error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>msgctl</span><span class=p>(</span><span class=kt>int</span> <span class=n>msqid</span><span class=p>,</span> <span class=kt>int</span> <span class=n>cmd</span><span class=p>,</span> <span class=k>struct</span> <span class=n>msqid_ds</span> <span class=o>*</span><span class=n>buf</span><span class=p>);</span></span></span></code></pre></div><ul><li><code>msqid</code> è un identificatore di coda di messaggi.</li><li><code>cmd</code> specifica l&rsquo;operazione da eseguire sulla coda:<ul><li><code>IPC_RMID</code>: rimuove immediatamente la coda di messaggi. Tutti i messaggi non letti vengono persi, e qualsiasi lettore/scrittore bloccato viene risvegliato (errno impostato a EIDRM). Per questa operazione, buf viene ignorato.</li><li><code>IPC_STAT</code>: Posiziona una copia della struttura dati msqid ds associata a questa coda di messaggi nel buffer indicato da buf</li><li><code>IPC_SET</code>: Aggiorna campi selezionati della struttura dati msqid ds associata a questa coda di messaggi usando valori forniti nel buffer indicato da buf</li></ul></li></ul><details><summary><b>Esempio su come rimuovere una coda di messaggi</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>msgctl</span><span class=p>(</span><span class=n>msqid</span><span class=p>,</span> <span class=n>IPC_RMID</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>errExit</span><span class=p>(</span><span class=s>&#34;msgctl failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>else</span>
</span></span><span class=line><span class=cl>	<span class=nf>printf</span><span class=p>(</span><span class=s>&#34;message queue removed successfully</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span></span></span></code></pre></div></details><h3 id=struttura-msqid_ds>Struttura msqid_ds</h3><p>Per ogni coda di messaggi, il kernel ha associato una struttura chiamata <code>msqid_ds</code> della seguente forma:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>msqid_ds</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>ipc_perm</span> <span class=n>msg_perm</span><span class=p>;</span> <span class=cm>/* Ownership and permissions */</span>
</span></span><span class=line><span class=cl>	<span class=n>time_t</span> <span class=n>msg_stime</span><span class=p>;</span> <span class=cm>/* Time of last msgsnd() */</span>
</span></span><span class=line><span class=cl>	<span class=n>time_t</span> <span class=n>msg_rtime</span><span class=p>;</span> <span class=cm>/* Time of last msgrcv() */</span>
</span></span><span class=line><span class=cl>	<span class=n>time_t</span> <span class=n>msg_ctime</span><span class=p>;</span> <span class=cm>/* Time of last change */</span>
</span></span><span class=line><span class=cl>	<span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>__msg_cbytes</span><span class=p>;</span> <span class=cm>/* Number of bytes in queue */</span>
</span></span><span class=line><span class=cl>	<span class=n>msgqnum_t</span> <span class=n>msg_qnum</span><span class=p>;</span> <span class=cm>/* Number of messages in queue */</span>
</span></span><span class=line><span class=cl>	<span class=n>msglen_t</span> <span class=n>msg_qbytes</span><span class=p>;</span> <span class=cm>/* Maximum bytes in queue */</span>
</span></span><span class=line><span class=cl>	<span class=n>pid_t</span> <span class=n>msg_lspid</span><span class=p>;</span> <span class=cm>/* PID of last msgsnd() */</span>
</span></span><span class=line><span class=cl>	<span class=n>pid_t</span> <span class=n>msg_lrpid</span><span class=p>;</span> <span class=cm>/* PID of last msgrcv() */</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></div><p>Con <code>IPC_STAT</code> e <code>IPC_SET</code> possiamo rispettivamente ottenere e aggiornare
questa struttura di dati.</p><details><summary><b>Esempio su come cambiare i limiti di dimensione di una message queue</b></summary><p>struct msqid_ds ds;
// Get the data structure of a message queue
if (msgctl(msqid, IPC_STAT, &ds) == -1)
errExit(&ldquo;msgctl&rdquo;);</p><p>// Change the upper limit on the number of bytes in the mtext
// fields of all messages in the message queue to 1 Kbyte
ds.msg_qbytes = 1024;</p><p>// Update associated data structure in kernel
if (msgctl(msqid, IPC_SET, &ds) == -1)
errExit(&ldquo;msgctl&rdquo;);</p></details><h2 id=visione-conclusiva-delle-interfacce-system-v>Visione conclusiva delle interfacce System V</h2><table><thead><tr><th>Interfaccia</th><th>Coda di messaggi</th><th>Semafori</th><th>Memoria condivisa</th></tr></thead><tbody><tr><td>File header</td><td><code>&lt;sys/msg.h></code></td><td><code>&lt;sys/sem.h></code></td><td><code>&lt;sys/shm.h></code></td></tr><tr><td>Struttura dati</td><td><code>msqid_ds</code></td><td><code>semid_ds</code></td><td><code>shmid_ds</code></td></tr><tr><td>Creazione/Apertura</td><td><code>msgget(..)</code></td><td><code>semget(..)</code></td><td><code>shmget(...)</code></td></tr><tr><td>Chiusura</td><td>nessuna</td><td>nessuna</td><td><code>shmdt(..)</code></td></tr><tr><td>Operazioni di controllo</td><td><code>msgctl(..)</code></td><td><code>semctl(..)</code></td><td><code>shmctl(..)</code></td></tr><tr><td>Eseguire operazioni di IPC</td><td><code>msgsnd(..)</code> <code>msgrcv(...)</code></td><td><code>semop()</code> per aggiustare i valori</td><td>accesso diretto alla memoria condivisa</td></tr></tbody></table><footer><p>Contenuto basato sulle slide del corso di Sistemi Operativi A.A Laboratorio 2021-2022 UniVR. Copyright degli autori delle slide originali.
<a href=https://github.com/seekbytes/oslab/edit/main/content/lezioni/5_coda_messaggi.md>Modifica questa pagina</a></p></footer></div></body></html>