<!doctype html><html lang=it><head><meta charset=utf-8><meta name=author content="SeekBytes"><meta name=viewport content="width=device-width,initial-scale=1"><title>Lezione 4.B - IPC e Segnali</title><link href=https://seekbytes.github.io/oslab/css/style.css rel=stylesheet type=text/css><link href=https://seekbytes.github.io/oslab/css/syntax.css rel=stylesheet type=text/css><link href=https://seekbytes.github.io/oslab/css/print.css rel=stylesheet media=print type=text/css><meta name=description content="Introduzione ai segnali (inviare un segnale, gestire un segnale)."></head><body class=flex><div class=navbar-lat><div class=links><h2>Indice</h2><nav id=TableOfContents><ul><li><a href=#concetti-fondamentali>Concetti fondamentali</a></li><li><a href=#tipi-di-segnali>Tipi di segnali</a></li><li><a href=#gestione-di-una-signal>Gestione di una Signal</a><ul><li><a href=#signal>Signal</a></li><li><a href=#pause>Pause</a></li><li><a href=#sleep>Sleep</a></li><li><a href=#mandare-un-segnale-kill>Mandare un segnale (kill)</a></li><li><a href=#alarm>Alarm</a></li></ul></li><li><a href=#impostare-o-bloccare-un-segnale>Impostare o bloccare un segnale</a><ul><li><a href=#set-di-segnali-sigemptyset-e-sigfillset>Set di segnali (sigemptyset e sigfillset)</a></li><li><a href=#sigaddset-e-sigdelset>Sigaddset e Sigdelset</a></li><li><a href=#sigprocmask>Sigprocmask</a></li></ul></li></ul></nav><h3>Contenuti</h3><ul><li><a href=https://seekbytes.github.io/oslab/lezioni/0-sistemi-operativi-laboratorio/>Lezione 0 - Introduzione a Sistemi Operativi Laboratorio</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/1-a-concetti-fondamentali/>Lezione 1.A - Concetti fondamentali: Processi e Programmi</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/1-b-file-system/>Lezione 1.B - Concetti fondamentali: File System</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/2-processi/>Lezione 2 - Processi</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/3-mentos/>Lezione 3.A - Fondamentali di MentOS</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/3-b-mentos-scheduling/>Lezione 3.B - MentOS Scheduling</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/4-a-semafori-ipc/>Lezione 4.A - IPC e Semafori</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/4-b-segnali-ipc/>Lezione 4.B - IPC e Segnali</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/5-memoria-condivisa-coda-di-messaggi/>Lezione 5 - Memoria condivisa e coda di messaggi</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/6-pipe-fifo/>Lezione 6 - Pipe e FIFO</a></li></ul><a href=../>Sezione principale</a></div></div><div class=content><a href=https://seekbytes.github.io/oslab/ id=returnBack>Ritorna indietro</a><h1>Lezione 4.B - IPC e Segnali</h1><p class=details>Pubblicato il 1/10/22 da SeekBytes – 1860 parole</p><h2 id=concetti-fondamentali>Concetti fondamentali</h2><p>Un segnale è una notifica a un processo che si è verificato un evento. Essi interrompono il normale flusso di esecuzione di un programma; nella maggior parte dei casi, non è possibile prevedere esattamente quando un segnale arriverà.</p><p>Si dice che un segnale sia generato da qualche evento. Una volta generato, un segnale viene successivamente consegnato ad un processo. Tra il momento in cui viene generato e il momento in cui viene consegnato, si dice che un segnale è in sospeso. Normalmente, un segnale in sospeso viene consegnato ad un processo non appena è programmato per essere eseguito, o immediatamente se il processo è già in esecuzione.</p><p>Alla consegna di un segnale, un processo esegue una delle seguenti azioni predefinite, a seconda del segnale:</p><ul><li>Il processo viene terminato (ucciso).</li><li>Il processo viene sospeso (fermato).</li><li>Il processo viene ripreso dopo essere stato precedentemente fermato.</li><li>Il segnale viene ignorato. Viene scartato dal kernel e non ha alcun effetto sul processo. Il processo esegue un gestore di segnale, cioè una funzione scritta dal programmatore che esegue compiti appropriati in risposta alla consegna di un segnale.</li></ul><h2 id=tipi-di-segnali>Tipi di segnali</h2><p>Segnali per terminare un processo:</p><ul><li><code>SIGTERM</code> viene consegnato per terminare in modo sicuro un processo. Un&rsquo;applicazione ben progettata applicazione dovrebbe avere un gestore per <code>SIGTERM</code> che causa l&rsquo;uscita l&rsquo;applicazione ad uscire con grazia.</li><li><code>SIGINT</code> termina un processo (&ldquo;interrupt process&rdquo;). Viene inviato quando l&rsquo;utente digita il carattere Control-C.</li><li><code>SIGQUIT</code> termina un processo e lo induce a produrre un core dump, che può essere usato per il debug.</li><li><code>SIGKILL</code> termina un processo (sempre!). Non può essere bloccato, ignorato, o catturato da un gestore.</li></ul><p>Segnali per stoppare e riesumare un processo:</p><ul><li><code>SIGSTOP</code> ferma un processo (sempre!). Non può essere bloccato, ignorato o catturato da un gestore.</li><li><code>SIGCONT</code> riprende un processo precedentemente fermato.</li></ul><p>Altri segnali:</p><ul><li><code>SIGPIPE</code> viene generato quando un processo cerca di scrivere su un PIPE, un FIFO per il quale non esiste un processo lettore corrispondente (vedi capitolo PIPE/FIFO).</li><li><code>SIGALRM</code> viene consegnato a un processo allo scadere di un timer in tempo reale impostato da una chiamata all&rsquo;allarme (vedere le prossime diapositive).</li><li><code>SIGUSR1</code> e <code>SIGUSR2</code> sono disponibili per scopi definiti dal programmatore. Il kernel non genera mai questi segnali per un processo.</li></ul><p>La lista completa dei segnali disponibili in Linux può essere recuperata con il comando bash &ldquo;man 7 signal&rdquo;.</p><table><thead><tr><th>Nome</th><th>Numero</th><th>Può essere gestito?</th><th>Azione di default</th></tr></thead><tbody><tr><td><code>SIGTERM</code></td><td>15</td><td>Sì</td><td>termina un processo</td></tr><tr><td><code>SIGINT</code></td><td>2</td><td>Sì</td><td>termina un processo</td></tr><tr><td><code>SIGQUIT</code></td><td>3</td><td>Sì</td><td>Dump di un processo e termina un processo</td></tr><tr><td><code>SIGKILL</code></td><td>9</td><td><strong>no</strong></td><td>Termina un processo</td></tr><tr><td><code>SIGSTOP</code></td><td>17</td><td><strong>no</strong></td><td>Ferma un processo</td></tr><tr><td><code>SIGCONT</code></td><td>19</td><td>Sì</td><td>Riesuma un processo che era stato fermato</td></tr><tr><td><code>SIGPIPE</code></td><td>13</td><td>Sì</td><td>Termina un processo</td></tr><tr><td><code>SIGALRM</code></td><td>14</td><td>Sì</td><td>Termina un processo</td></tr><tr><td><code>SIGUSR1</code></td><td>30</td><td>Sì</td><td>Termina un processo</td></tr><tr><td><code>SIGUSR2</code></td><td>31</td><td>Sì</td><td>Termina un processo</td></tr></tbody></table><h2 id=gestione-di-una-signal>Gestione di una Signal</h2><p>Un gestore di segnali (chiamato anche &ldquo;catturatore&rdquo; di segnali) è una funzione che viene chiamata quando un segnale specificato viene consegnato ad un processo. Ha sempre la seguente forma generale:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>sigHandler</span><span class=p>(</span><span class=kt>int</span> <span class=n>sig</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=cm>/* Code for the handler */</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Questa funzione non restituisce nulla (void) e prende un argomento intero (<code>sig</code>). Quando il gestore del segnale è invocato dal kernel, <code>sig</code> è impostato al segnale consegnato al processo. Tipicamente, <code>sig</code> è usato per determinare quale segnale ha causato l&rsquo;invocazione del gestore invocato quando uno stesso gestore cattura diversi tipi di segnali.</p><p>L&rsquo;invocazione di un gestore di segnali può interrompere il flusso del programma principale in qualsiasi momento. Il kernel chiama il gestore del segnale, e quando il gestore ritorna, l&rsquo;esecuzione del programma riprende dal punto in cui il gestore l&rsquo;ha interrotta.</p><h3 id=signal>Signal</h3><p>La chiamata di sistema <code>signal()</code> cambia il signal-handler predefinito per un segnale definito in un processo.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=nf>void</span> <span class=p>(</span><span class=o>*</span><span class=n>sighandler_t</span><span class=p>)(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// Returns previous signal disposition on success, or SIG_ERR on error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>sighandler_t</span> <span class=nf>signal</span><span class=p>(</span><span class=kt>int</span> <span class=n>signum</span><span class=p>,</span> <span class=n>sighandler_t</span> <span class=n>handler</span><span class=p>);</span></span></span></code></pre></div><p><code>signum</code> identifica il segnale di cui vogliamo cambiare la disposizione nel processo. <code>handler</code> può essere uno dei seguenti:</p><ul><li>l&rsquo;indirizzo di un gestore di segnale definito dall&rsquo;utente.</li><li>la costante <code>SIG_DFL</code>, che reimposta la disposizione predefinita del processo per il segnale signum.</li><li>la costante <code>SIG_IGN</code>, che imposta il processo a ignorare la consegna del segnale signum.</li></ul><details><summary><b>Esempio di come catturare i segnali</b></summary>
void sigHandler(int sig) {
printf(&ldquo;The signal %s was caught!\n&rdquo;,
(sig == SIGINT)? &ldquo;Ctrl-C&rdquo; : &ldquo;signal User-1&rdquo;);
}
int main (int argc, char *argv[]) {
// setting sigHandler to be executed for SIGINT or SIGUSR1
if (signal(SIGINT, sigHandler) == SIG_ERR ||
signal(SIGUSR1, sigHandler) == SIG_ERR) {
errExit(&ldquo;change signal handler failed&rdquo;);
}
// Do something else here. During this time, if SIGINT/SIGUSR1
// is delivered, sigHandler will be used to handle the signal.
// Reset the default process disposition for SIGINT and SIGUSR1
if (signal(SIGINT, SIG_DFL) == SIG_ERR ||
signal(SIGUSR1, SIG_DFL) == SIG_ERR) {
errExit(&ldquo;reset signal handler failed&rdquo;);
}
return 0;
}</details><p>Cose da tenere a mente quando si utilizzano signal handlers:</p><ul><li><code>SIGKILL</code> e <code>SIGSTOP</code> non possono essere catturati.</li><li>Un segnale è un evento asincrono. Non possiamo prevedere quando arriva.</li><li>Quando un gestore di segnali viene invocato, il segnale che ha causato la sua invocazione è automaticamente bloccato. Viene sbloccato quando il gestore del segnale ritorna al normale flusso di esecuzione del programma.</li><li>Se un segnale bloccato viene generato più volte, quando viene sbloccato, viene consegnato al processo solo una volta!</li><li>L&rsquo;esecuzione di un gestore di segnali può essere interrotta dalla consegna di un segnale non bloccato.</li><li>Le disposizioni dei segnali sono ereditate tra processo padre e processo figlio.</li></ul><h3 id=pause>Pause</h3><p>Chiamando pause si sospende l&rsquo;esecuzione del processo finché la chiamata non viene interrotta da un gestore di segnale (o fino a quando un segnale non gestito termina il processo).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// Always return -1 with errno set to EINTR
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>pause</span><span class=p>();</span></span></span></code></pre></div><h3 id=sleep>Sleep</h3><p>La funzione sleep sospende l&rsquo;esecuzione del processo chiamante per il numero di secondi specificato nell&rsquo;argomento <code>seconds</code> o fino a quando un segnale viene catturato (interrompendo così la chiamata).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>unsigned</span> <span class=kt>int</span> <span class=nf>sleep</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>seconds</span><span class=p>);</span> <span class=c1>// Returns 0 on normal completion, or number of unslept seconds if prematurely terminated
</span></span></span></code></pre></div><details><summary><b>Esempio di waiting di un segnale</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>sigHandler</span><span class=p>(</span><span class=kt>int</span> <span class=n>sig</span><span class=p>)</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>	<span class=n>printf</span><span class=p>(</span><span class=s>&#34;Well done!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span> <span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>signal</span><span class=p>(</span><span class=n>SIGINT</span><span class=p>,</span> <span class=n>sigHandler</span><span class=p>)</span> <span class=o>==</span> <span class=n>SIG_ERR</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=n>errExit</span><span class=p>(</span><span class=s>&#34;change signal handler failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>time</span> <span class=o>=</span> <span class=mi>30</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>printf</span><span class=p>(</span><span class=s>&#34;We can wait for %d seconds!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>time</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>time</span> <span class=o>=</span> <span class=n>sleep</span><span class=p>(</span><span class=n>time</span><span class=p>);</span> <span class=c1>// the process is suspended for max. 30sec.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>printf</span><span class=p>(</span><span class=s>&#34;%s!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=n>time</span><span class=o>==</span><span class=mi>0</span><span class=p>)</span><span class=o>?</span> <span class=s>&#34;out of time&#34;</span><span class=p>,</span> <span class=s>&#34;just in time&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></details><h3 id=mandare-un-segnale-kill>Mandare un segnale (kill)</h3><p>La system call kill manda un segnale ad un altro processo.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// Returns 0 on success, or -1 on error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>kill</span><span class=p>(</span><span class=n>pid_t</span> <span class=n>pid</span><span class=p>,</span> <span class=kt>int</span> <span class=n>sig</span><span class=p>);</span></span></span></code></pre></div><p>L&rsquo;argomento pid identifica uno o più processi a cui il segnale specificato da sig deve essere inviato.</p><ul><li>(pid > 0): il segnale viene inviato al processo con PID uguale a pid.</li><li>(pid = 0): il segnale viene inviato ad ogni processo nello stesso gruppo di processi del processo chiamante, incluso il processo chiamante stesso.</li><li>(pid &lt; 0): il segnale viene inviato a tutti i processi nel gruppo di processi il cui ID è uguale al valore assoluto di pid.</li><li>(pid = -1): il segnale viene inviato ad ogni processo per il quale il processo chiamante ha il permesso di inviare un segnale, eccetto init e il processo
stesso.</li></ul><details><summary><b>Inviare un segnale SIGKILL ad un processo figlio</b></summary>
int main (int argc, char <em>argv[]) {
pid_t child = fork();
switch(child) {
case -1:
errExit(&ldquo;fork&rdquo;);
case 0: /</em> Child process <em>/
while(1); // &lt;- child is stuck here!
default: /</em> Parent process */
sleep(10); // wait 10 seconds
kill(child, SIGKILL); // kill the child process
}
return 0;
}</details><h3 id=alarm>Alarm</h3><p>La chiamata al sistema di allarme fa in modo che un segnale <code>SIGALRM</code> sia consegnato al al processo chiamante dopo un ritardo fisso.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// Always succeeds, returning number of seconds remaining on
</span></span></span><span class=line><span class=cl><span class=c1>// any previously set timer, or 0 if no timer previously was set
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>unsigned</span> <span class=kt>int</span> <span class=nf>alarm</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>seconds</span><span class=p>);</span></span></span></code></pre></div><p>L&rsquo;argomento seconds specifica il numero di secondi nel futuro in cui il timer deve scadere. In quel momento, un segnale SIGALRM viene consegnato al processo chiamante. L&rsquo;impostazione di un timer con allarme sovrascrive qualsiasi timer precedentemente impostato.</p><details><summary><b>Impostare un timer con la syscall alarm</b></summary><p>void sigHandler(int sig) { printf(&ldquo;Out of time!\n&rdquo;); _exit(0); }</p><p>int main (int argc, char *argv[]) {
if (signal(SIGALRM, sigHandler) == SIG_ERR)
errExit(&ldquo;change signal handler failed&rdquo;);</p><pre><code>int time = 30;
printf(&quot;We have %d seconds to complete the job!\n&quot;, time);
alarm(time); // setting a timer

/* Do something else here. */
time = alarm(0); // disabling timer
printf(&quot;%s seconds before timer expirations!\n&quot;, time);
return 0;
</code></pre><p>}</p></details><h2 id=impostare-o-bloccare-un-segnale>Impostare o bloccare un segnale</h2><h3 id=set-di-segnali-sigemptyset-e-sigfillset>Set di segnali (sigemptyset e sigfillset)</h3><p>Il tipo di dati sigset t rappresenta un insieme di segnali. Le funzioni <code>sigemptyset</code> e <code>sigfillet</code> devono essere utilizzate per inizializzare un insieme di segnali, prima di utilizzarlo in qualsiasi altro modo.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>sigset_t</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// Both return 0 on success, or -1 on error.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>sigemptyset</span><span class=p>(</span><span class=n>sigset_t</span> <span class=o>*</span><span class=n>set</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sigfillset</span><span class=p>(</span><span class=n>sigset_t</span> <span class=o>*</span><span class=n>set</span><span class=p>);</span></span></span></code></pre></div><p><code>sigemptyset</code> inizializza un insieme di segnali per non contenere alcun segnale.
<code>sigfillset</code> inizializza un insieme per contenere tutti i segnali.</p><h3 id=sigaddset-e-sigdelset>Sigaddset e Sigdelset</h3><p>Dopo l&rsquo;inizializzazione, i singoli segnali possono essere aggiunti a un insieme usando <code>sigaddset</code> e rimossi usando <code>sigdelset</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// Both return 0 on success, or -1 on error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>sigaddset</span><span class=p>(</span><span class=n>sigset_t</span> <span class=o>*</span><span class=n>set</span><span class=p>,</span> <span class=kt>int</span> <span class=n>sig</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sigdelset</span><span class=p>(</span><span class=n>sigset_t</span> <span class=o>*</span><span class=n>set</span><span class=p>,</span> <span class=kt>int</span> <span class=n>sig</span><span class=p>);</span></span></span></code></pre></div><p>Sia per <code>sigaddset</code> che per <code>sigdelset</code>, l&rsquo;argomento sig è un numero di segnale. La funzione sigismember è utilizzata per verificare l&rsquo;appartenenza ad un insieme.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// Restituisce 1 se sig è un membro di set, altrimenti 0
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>sigismember</span><span class=p>(</span><span class=k>const</span> <span class=n>sigset_t</span> <span class=o>*</span><span class=n>set</span><span class=p>,</span> <span class=kt>int</span> <span class=n>sig</span><span class=p>);</span></span></span></code></pre></div><h3 id=sigprocmask>Sigprocmask</h3><p>Per ogni processo, il kernel mantiene una maschera di segnale, cioè un insieme di segnali la cui consegna al processo è attualmente bloccata. Se un segnale - che è bloccato - è inviato ad un processo, la consegna di quel segnale è ritardata fino a quando non viene sbloccato, rimuovendolo dalla maschera dei segnali del processo. La chiamata di sistema <code>sigprocmask</code> può essere usata in qualsiasi momento per aggiungere esplicitamente segnali alla maschera dei segnali e rimuovere segnali da essa.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// Returns 0 on success, or -1 on error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>sigprocmask</span><span class=p>(</span><span class=kt>int</span> <span class=n>how</span><span class=p>,</span> <span class=k>const</span> <span class=n>sigset_t</span> <span class=o>*</span><span class=n>set</span><span class=p>,</span> <span class=n>sigset_t</span> <span class=o>*</span><span class=n>oldset</span><span class=p>);</span></span></span></code></pre></div><p>L&rsquo;argomento <code>how</code> determina i cambiamenti che <code>sigprocmask</code> fa alla maschera di segnale:</p><ul><li><code>SIG_BLOCK</code>: L&rsquo;insieme dei segnali bloccati è l&rsquo;unione dell&rsquo;insieme corrente e l&rsquo;argomento set.</li><li><code>SIG_UNBLOCK</code>: I segnali nell&rsquo;argomento set vengono rimossi dall&rsquo;attuale set di segnali bloccati. È lecito tentare di sbloccare un segnale che non è bloccato.</li><li><code>SIG_SETMASK</code>: L&rsquo;insieme dei segnali bloccati viene impostato sull&rsquo;argomento set. In ogni caso, se l&rsquo;argomento oldset non è NULL, esso punta a un sigset_t che viene utilizzato per restituire la precedente maschera di segnale. Se vogliamo recuperare la maschera di segnale senza cambiarla, allora possiamo specificare NULL per l&rsquo;argomento set, nel qual caso l&rsquo;argomento <code>how</code> viene ignorato.</li></ul><details><summary><b>Bloccare un segnale a parte SIGTERM</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span> <span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>sigset_t</span> <span class=n>mySet</span><span class=p>,</span> <span class=n>prevSet</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=c1>// inizializziamo mySet per contenere tutti i segnali
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>sigfillset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mySet</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=c1>// rimuove SIGTERM da mySet
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>sigdelset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mySet</span><span class=p>,</span> <span class=n>SIGTERM</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=c1>// bloccare tutti i segnali tranne SIGTERM
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>sigprocmask</span><span class=p>(</span><span class=n>SIG_SETMASK</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>mySet</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>prevSet</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=c1>// il processo non è interrotto da segnali eccetto SIGTERM
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// resetta la maschera dei segnali del processo
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>sigprocmask</span><span class=p>(</span><span class=n>SIG_SETMASK</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>prevSet</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=c1>// il processo non è interrotto da segnali in prevSet
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></details><footer><p>Contenuto basato sulle slide del corso di Sistemi Operativi A.A Laboratorio 2021-2022 UniVR. Copyright degli autori delle slide originali.
<a href=https://github.com/seekbytes/oslab/edit/main/content/lezioni/4_b_segnali.md>Modifica questa pagina</a></p></footer></div></body></html>