<!doctype html><html lang=it><head><meta charset=utf-8><meta name=author content="SeekBytes"><meta name=viewport content="width=device-width,initial-scale=1"><title>Lezione 1.B - Concetti fondamentali: File System</title><link href=https://seekbytes.github.io/oslab/css/style.css rel=stylesheet type=text/css><link href=https://seekbytes.github.io/oslab/css/syntax.css rel=stylesheet type=text/css><link href=https://seekbytes.github.io/oslab/css/print.css rel=stylesheet media=print type=text/css><meta name=description content="I file: open, write su file e su directory. Attributi di un file e permessi di file/cartelle."></head><body class=flex><div class=navbar-lat><div class=links><h2>Indice</h2><nav id=TableOfContents><ul><li><a href=#file>File</a><ul><li><a href=#apertura-file-open>Apertura file (Open)</a></li><li><a href=#umask>Umask</a></li><li><a href=#read>Read</a></li><li><a href=#write>Write</a></li><li><a href=#lseek>Lseek</a></li><li><a href=#close>Close</a></li><li><a href=#unlink>Unlink</a></li><li><a href=#attributi>Attributi</a><ul><li><a href=#stat>stat</a></li><li><a href=#lstat>lstat</a></li><li><a href=#fstat>fstat</a></li><li><a href=#permessi-dei-file-e-tipo-di-file>Permessi dei file e tipo di file</a></li><li><a href=#access>access</a></li></ul></li><li><a href=#cambiare-i-permessi-ad-un-file>Cambiare i permessi ad un file</a><ul><li><a href=#chmod>chmod</a></li><li><a href=#fchmod>fchmod</a></li></ul></li></ul></li><li><a href=#cartelle>Cartelle</a><ul><li><a href=#operazioni>Operazioni</a><ul><li><a href=#mkdir>mkdir</a></li><li><a href=#rmdir>rmdir</a></li></ul></li><li><a href=#opendir-e-closedir>Opendir e closedir</a></li><li><a href=#readdir>Readdir</a></li></ul></li></ul></nav><h3>Contenuti</h3><ul><li><a href=https://seekbytes.github.io/oslab/lezioni/0-sistemi-operativi-laboratorio/>Lezione 0 - Introduzione a Sistemi Operativi Laboratorio</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/1-a-concetti-fondamentali/>Lezione 1.A - Concetti fondamentali: Processi e Programmi</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/1-b-file-system/>Lezione 1.B - Concetti fondamentali: File System</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/2-processi/>Lezione 2 - Processi</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/3-mentos/>Lezione 3.A - Fondamentali di MentOS</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/3-b-mentos-scheduling/>Lezione 3.B - MentOS Scheduling</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/4-a-semafori-ipc/>Lezione 4.A - IPC e Semafori</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/4-b-segnali-ipc/>Lezione 4.B - IPC e Segnali</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/5-memoria-condivisa-coda-di-messaggi/>Lezione 5 - Memoria condivisa e coda di messaggi</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/6-pipe-fifo/>Lezione 6 - Pipe e FIFO</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/7-a-struttura-mentos/>Lezione 7.A - Struttura di MentOS</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/7-b-mentos-system-call/>Lezione 7.B - System Call MentOS</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/7-c-mentos-deadlock/>Lezione 7.C - MentOS Deadlock</a></li></ul><a href=../>Sezione principale</a></div></div><div class=content><a href=https://seekbytes.github.io/oslab/ id=returnBack>Ritorna indietro</a><h1>Lezione 1.B - Concetti fondamentali: File System</h1><p class=details>Pubblicato il 10/29/21 da SeekBytes – 2753 parole</p><h2 id=file>File</h2><h3 id=apertura-file-open>Apertura file (Open)</h3><p>La system call open apre un file esistente. In alternativa, può creare e quindi aprire un nuovo file.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/stat.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;fcntl.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// Ritorna il file descriptor altrimenti -1 in caso di fallimento
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>open</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>pathname</span><span class=p>,</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>,</span> <span class=p>...</span><span class=cm>/*mode_t mode */</span><span class=p>);</span></span></span></code></pre></div><p>Se ha successo, ritorna il file descriptor che è usato per riferirsi al file in tutte le system call successivi. Il file da essere aperto / creato è identificato dall&rsquo;argomento <code>pathname</code>.</p><p>L&rsquo;argomento <code>flags</code> è una bit mask di una o più costanti che specifica in che modalità aprire il file.</p><table><thead><tr><th>FLAG</th><th>DESCRIZIONE</th></tr></thead><tbody><tr><td><code>O_RDONLY</code></td><td>Aperto in sola <strong>lettura</strong></td></tr><tr><td><code>O_WRONLY</code></td><td>Aperto in sola <strong>scrittura</strong></td></tr><tr><td><code>O_RDWR</code></td><td>Aperto sia in scrittura che in lettura</td></tr><tr><td><code>O_TRUNC</code></td><td>Tronca il file esistente</td></tr><tr><td><code>O_APPEND</code></td><td>Tutto ciò che viene scritto è dopo il contenuto del file</td></tr><tr><td><code>O_CREAT</code></td><td>Crea un file se non esiste già</td></tr><tr><td><code>O_EXCL</code></td><td>Utilizzata insieme alla O_CREAT, forza la creazione del file</td></tr></tbody></table><p>Quando un nuovo file viene creato, allora anche il terzo argomento <code>mode</code> viene considerato.</p><p>L&rsquo;argomento <code>mode</code> è una bitmask di uno o dei seguenti valori che specificano i permessi per il nuovo file.</p><table><thead><tr><th>FLAG</th><th>DESCRIZIONE</th></tr></thead><tbody><tr><td><code>S_IRWXU</code></td><td>l&rsquo;utente ha permessi di lettura, scrittura ed esecuzione</td></tr><tr><td><code>S_IRUSR</code></td><td>l&rsquo;utente ha permessi di lettura</td></tr><tr><td><code>S_IWUSR</code></td><td>l&rsquo;utente ha permessi di scrittura</td></tr><tr><td><code>S_IXUSR</code></td><td>l&rsquo;utente ha permessi di esecuzione</td></tr><tr><td><code>S_IRWXG</code></td><td>il gruppo ha permessi di lettura, scrittura ed esecuzione</td></tr><tr><td><code>S_IRGRP</code></td><td>il gruppo ha permessi di lettura</td></tr><tr><td><code>S_IWGRP</code></td><td>il gruppo ha permessi di scrittura</td></tr><tr><td><code>S_IXGRP</code></td><td>il gruppo ha permessi di esecuzione</td></tr><tr><td><code>S_IRWXO</code></td><td>others hanno permessi di lettura, scrittura ed esecuzione</td></tr><tr><td><code>S_IROTH</code></td><td>others hanno permessi di lettura</td></tr><tr><td><code>S_IWOTH</code></td><td>others hanno permessi di scrittura</td></tr><tr><td><code>S_IXOTH</code></td><td>others hanno permessi di esecuzione</td></tr></tbody></table><h3 id=umask>Umask</h3><p>La maschera per la creazione di file utente è un attributo del processo che specifica quali permessi dovrebbero essere sempre disattivati quando nuovi file sono creati da un processo. Nella maggior parte delle shell, il valore di default è 022.</p><p>I permessi assegnati ad un nuovo file sono: <code>mode & ~umask</code> ovvero <code>mode AND (NOT mask)</code>. Puoi gestire umask tramite la shell utilizzando il comando <code>umask</code>.</p><details><summary><b>Esempio con umask e bit</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>Requested file perms:		rw-rw---- <span class=o>(</span>&lt;- this is what we asked<span class=o>)</span>
</span></span><span class=line><span class=cl>Process umask: 			----w--w- <span class=o>(</span>&lt;- this is what we are denied<span class=o>)</span>
</span></span><span class=line><span class=cl>Actual file perms: 		rw-r----- <span class=o>(</span>&lt;- So, this is what we get<span class=o>)</span></span></span></code></pre></div></details><details><summary><b>Esempio con la open</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=n>fd</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// Open existing file for only writing.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>fd</span> <span class=o>=</span> <span class=n>open</span><span class=p>(</span><span class=s>&#34;myfile&#34;</span><span class=p>,</span> <span class=n>O_WRONLY</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// Open new or existing file for reading/writing, truncating to zero bytes; file permissions read+write only for owner.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>fd</span> <span class=o>=</span> <span class=n>open</span><span class=p>(</span><span class=s>&#34;myfile1&#34;</span><span class=p>,</span> <span class=n>O_RDWR</span> <span class=o>|</span> <span class=n>O_CREAT</span> <span class=o>|</span> <span class=n>O_TRUNC</span><span class=p>,</span> <span class=n>S_IRUSR</span> <span class=o>|</span> <span class=n>S_IWUSR</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// Create and open a new file for reading/writing; file permissions read+write only for owner.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>fd</span> <span class=o>=</span> <span class=n>open</span><span class=p>(</span><span class=s>&#34;myfile2&#34;</span><span class=p>,</span> <span class=n>O_RDWR</span> <span class=o>|</span> <span class=n>O_CREAT</span> <span class=o>|</span> <span class=n>O_EXCL</span><span class=p>,</span> <span class=n>S_IRUSR</span> <span class=o>|</span> <span class=n>S_IWUSR</span><span class=p>);</span></span></span></code></pre></div></details><h3 id=read>Read</h3><p>La system call read legge dati da un file descriptor. Ritorna il numero di byte letti oppure -1 se fallisce. L&rsquo;argomento <code>count</code> specifica il massimo numero di byte da leggere dal file descriptor. L&rsquo;argomento <code>buf</code> è l&rsquo;indirizzo di memoria in cui le informazioni lette vengono memorizzate.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// Ritorna il numero di byte letti, -1 in caso di errori
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>ssize_t</span> <span class=nf>read</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>buf</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>count</span><span class=p>);</span></span></span></code></pre></div><details><summary><b>Esempio: lettura di MAX_READ bytes da un file</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// Open existing file for reading.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>fd</span> <span class=o>=</span> <span class=n>open</span><span class=p>(</span><span class=s>&#34;myfile&#34;</span><span class=p>,</span> <span class=n>O_RDONLY</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>fd</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>errExit</span><span class=p>(</span><span class=s>&#34;open&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// A MAX_READ bytes buffer.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>char</span> <span class=n>buffer</span><span class=p>[</span><span class=n>MAX_READ</span> <span class=o>+</span> <span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Reading up to MAX_READ bytes from myfile.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>ssize_t</span> <span class=n>numRead</span> <span class=o>=</span> <span class=n>read</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>buffer</span><span class=p>,</span> <span class=n>MAX_READ</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>numRead</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>errExit</span><span class=p>(</span><span class=s>&#34;read&#34;</span><span class=p>);</span></span></span></code></pre></div></details><p>Nota: con un file, il valore di ritorno zero indica che si è raggiunto l&rsquo;<strong>End-of-File</strong>.</p><details><summary><b>Lettura di dati da terminale</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// A MAX_READ bytes buffer.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>char</span> <span class=n>buffer</span><span class=p>[</span><span class=n>MAX_READ</span> <span class=o>+</span> <span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=c1>// Reading up to MAX_READ bytes from STDIN.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>ssize_t</span> <span class=n>numRead</span> <span class=o>=</span> <span class=n>read</span><span class=p>(</span><span class=n>STDIN_FILENO</span><span class=p>,</span> <span class=n>buffer</span><span class=p>,</span> <span class=n>MAX_READ</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>numRead</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>errExit</span><span class=p>(</span><span class=s>&#34;read&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>buffer</span><span class=p>[</span><span class=n>numRead</span><span class=p>]</span> <span class=o>=</span> <span class=err>’\</span><span class=mi>0</span><span class=err>’</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>printf</span><span class=p>(</span><span class=s>&#34;Input data: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>buffer</span><span class=p>);</span></span></span></code></pre></div><p>Nota: con il terminale, la system call legge i caratteri fino a che non incontra la newline <code>\n</code>.</p></details><h3 id=write>Write</h3><p>La system call write scrive dati su un file descriptor. Ritorna il numero di caratteri scritti o -1 se fallisce. L&rsquo;argomento count specifica il numero di byte che il buffer <code>buf</code> contiene e che deve essere scritto sul file descriptor <code>fd</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// Ritorna il numero di byte scritti, -1 in caso di errori.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>ssize_t</span> <span class=nf>write</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>buf</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>count</span><span class=p>);</span></span></span></code></pre></div><details><summary><b>Scrittura 'Ciao Mondo' su un file</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// Open existing file for writing.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>fd</span> <span class=o>=</span> <span class=n>open</span><span class=p>(</span><span class=s>&#34;myfile&#34;</span><span class=p>,</span> <span class=n>O_WRONLY</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>fd</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>errExit</span><span class=p>(</span><span class=s>&#34;open&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// A buffer collecting the string.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>char</span> <span class=n>buffer</span><span class=p>[]</span> <span class=o>=</span> <span class=s>&#34;Ciao Mondo&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// Writing up to sizeof(buffer) bytes into myfile.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>ssize_t</span> <span class=n>numWrite</span> <span class=o>=</span> <span class=n>write</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>buffer</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>buffer</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>numWrite</span> <span class=o>!=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>buffer</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=n>errExit</span><span class=p>(</span><span class=s>&#34;write&#34;</span><span class=p>);</span></span></span></code></pre></div></details><details><summary><b>Scrittura 'Ciao Mondo' su terminale</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// A buffer collecting a string.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>char</span> <span class=n>buffer</span><span class=p>[]</span> <span class=o>=</span> <span class=s>&#34;Ciao Mondo&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// Writing up tp sizeof(buffer) bytes on STDOUT.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>ssize_t</span> <span class=n>numWrite</span> <span class=o>=</span> <span class=n>write</span><span class=p>(</span><span class=n>STDOUT_FILENO</span><span class=p>,</span> <span class=n>buffer</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>buffer</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>numWrite</span> <span class=o>!=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>buffer</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=n>errExit</span><span class=p>(</span><span class=s>&#34;write&#34;</span><span class=p>);</span></span></span></code></pre></div></details><h3 id=lseek>Lseek</h3><p>Per ogni file aperto, il kernel salva un <em>file offset</em> che è la posizione da dove la prossima lettura o scrittura inizierà. La system call <code>lseek</code> aggiusta la posizione dell&rsquo;offset di un file aperto.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// Ritorna la location dell&#39;offset, -1 in caso di errore.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>off_t</span> <span class=nf>lseek</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=n>off_t</span> <span class=n>offset</span><span class=p>,</span> <span class=kt>int</span> <span class=n>whence</span><span class=p>);</span></span></span></code></pre></div><p>L&rsquo;argomento <code>fd</code> specifica il file descriptor del file aperto, <code>offset</code> specifica un valore in byte, mentre <code>whence</code> indica il punto di partenza da cui l&rsquo;offset deve essere interpretato.</p><details><summary><b>Esempio</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// first byte of the file.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>off_t</span> <span class=n>current</span> <span class=o>=</span> <span class=n>lseek</span><span class=p>(</span><span class=n>fd1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>SEEK_SET</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// last byte of the file.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>off_t</span> <span class=n>current</span> <span class=o>=</span> <span class=n>lseek</span><span class=p>(</span><span class=n>fd2</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>SEEK_END</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// 10th byte past the current offset location of the file.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>off_t</span> <span class=n>current</span> <span class=o>=</span> <span class=n>lseek</span><span class=p>(</span><span class=n>fd3</span><span class=p>,</span> <span class=o>-</span><span class=mi>10</span><span class=p>,</span> <span class=n>SEEK_CUR</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// 10th byte after the current offset location of the file.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>off_t</span> <span class=n>current</span> <span class=o>=</span> <span class=n>lseek</span><span class=p>(</span><span class=n>fd4</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=n>SEEK_CUR</span><span class=p>);</span></span></span></code></pre></div></details><p>Valore di whence di esempio:</p><table><thead><tr><th>Costante</th><th>Descrizione</th></tr></thead><tbody><tr><td><code>SEEK_SET</code></td><td>Imposta il seek all&rsquo;offset indicato da <code>offset</code></td></tr><tr><td><code>SEEK_END</code></td><td>Imposta il seek a SEEK_END + <code>offset</code></td></tr><tr><td><code>SEEK_CURR</code></td><td>Imposta il seek a SEEK_CURR + <code>offset</code></td></tr></tbody></table><p><strong>Attenzione</strong>: qualsiasi chiamata a write/read modifica il file offset del file! È bene prestare molta attenzione quando si cerca di utilizzare la lseek e write/read.</p><h3 id=close>Close</h3><p>La system call close chiude un file descriptor aperto. Anche se il sistema operativo già chiude tutti i file descriptor quando il processo è terminato, è comunque buona pratica chiudere i file descriptor non necessari.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// Returns 0 on success, or -1 on error.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>close</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>);</span></span></span></code></pre></div><h3 id=unlink>Unlink</h3><p>La system call unlink permette di rimuovere un collegamento e se il collegamento è direttamente il file, allora lo rimuove. Unlink non può rimuovere una cartella (per questo vedi rmdir).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// Returns 0 on success, or -1 on error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>unlink</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>pathname</span><span class=p>);</span></span></span></code></pre></div><details><summary><b>Esempio di creazione, chiusura e rimozione di un file</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// Create a new file named myFile.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>fd</span> <span class=o>=</span> <span class=n>open</span><span class=p>(</span><span class=s>&#34;myFile&#34;</span><span class=p>,</span> <span class=n>O_CREAT</span> <span class=o>|</span> <span class=n>O_WRONLY</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// ... only writes as myFile is open in write-only
</span></span></span><span class=line><span class=cl><span class=c1>// Close the file descriptor fd
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>close</span><span class=p>(</span><span class=n>fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// Unlink (remove) myFile
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>unlink</span><span class=p>(</span><span class=s>&#34;myFile&#34;</span><span class=p>);</span></span></span></code></pre></div></details><h3 id=attributi>Attributi</h3><p>Le successive tre system call (stat, lstat e fstat) ritornano informazioni riguardo un file (compresa una cartella – su Linux una cartella è un file).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/stat.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// Return 0 on success or -1 on error.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>stat</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>pathname</span><span class=p>,</span> <span class=k>struct</span> <span class=n>stat</span> <span class=o>*</span><span class=n>statbuf</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>lstat</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>pathname</span><span class=p>,</span> <span class=k>struct</span> <span class=n>stat</span> <span class=o>*</span><span class=n>statbuf</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>fstat</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=k>struct</span> <span class=n>stat</span> <span class=o>*</span><span class=n>statbuf</span><span class=p>);</span></span></span></code></pre></div><h4 id=stat>stat</h4><p>La system call stat ritorna informazioni riguardo ad un file.</p><h4 id=lstat>lstat</h4><p>La system call lstat ritorna informazioni riguardo ad un collegamento ad un file.</p><h4 id=fstat>fstat</h4><p>Fstat è simile a stat solo che l&rsquo;accesso al file non è più per nome ma per file descriptor.</p><p>Tutte queste system call ritornano una struttura <code>stat</code> nel buffer puntato da statbuf. La struttura ha la seguente forma:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>stat</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>dev_t</span> <span class=n>st_dev</span><span class=p>;</span> <span class=c1>// IDs of device on which file resides.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>ino_t</span> <span class=n>st_ino</span><span class=p>;</span> <span class=c1>// I-node number of file. 
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>mode_t</span> <span class=n>st_mode</span><span class=p>;</span> <span class=c1>// File type and permissions.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>nlink_t</span> <span class=n>st_nlink</span><span class=p>;</span> <span class=c1>// Number of (hard) links to file. 
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>uid_t</span> <span class=n>st_uid</span><span class=p>;</span> <span class=c1>// User ID of file owner.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>gid_t</span> <span class=n>st_gid</span><span class=p>;</span> <span class=c1>// Group ID of file owner.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>dev_t</span> <span class=n>st_rdev</span><span class=p>;</span> <span class=c1>// IDs for device special files.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>off_t</span> <span class=n>st_size</span><span class=p>;</span> <span class=c1>// Total file size (bytes).
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>blksize_t</span> <span class=n>st_blksize</span><span class=p>;</span> <span class=c1>// Optimal block size for I/O (bytes).
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>blkcnt_t</span> <span class=n>st_blocks</span><span class=p>;</span> <span class=c1>// Number of (512B) blocks allocated. 
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>time_t</span> <span class=n>st_atime</span><span class=p>;</span> <span class=c1>// Time of last file access.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>time_t</span> <span class=n>st_mtime</span><span class=p>;</span> <span class=c1>// Time of last file modification. 
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>time_t</span> <span class=n>st_ctime</span><span class=p>;</span> <span class=c1>// Time of last status change.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span></span></span></code></pre></div><p>Spiegazione di alcuni campi:</p><ul><li><code>st_dev</code> (anche chiamato device id): identifica il dispositivo in cui il file risiede;</li><li><code>st_ino</code>: contiene il numero dell&rsquo;i-node del file. La combinazione del device id e st_ino identifica in modo univoco un file</li><li><code>st_uid</code>: id dell&rsquo;utente a cui il file appartiene</li><li><code>st_gid</code>: id del gruppo a cui il file appartiene</li><li><code>st_nlink</code> (conta dei collegamenti): numero dei collegamenti al file</li><li><code>st_atime</code>, <code>st_mtime</code>, <code>st_ctime</code>: contengono rispettivamente il tempo dell&rsquo;ultimo accesso, dell&rsquo;ultima modifica e dell&rsquo;ultima modifica alle informazioni dell&rsquo;i-node nel formato timestamp</li></ul><p><strong>Dimensione dei file, blocchi allocati e dimensione ottimale dei blocchi I/O</strong>:
Per i file regolari, il campo <code>st_size</code> è la dimensione totale del file in byte. Per un collegamento simbolico, questo campo contiene la lunghezza (in byte) del percorso indicato dal collegamento.
Il campo <code>st_blocks</code> indica il numero di blocchi effettivamente assegnati al file in unità di blocco da 512 byte (potrebbe essere più piccolo di quanto ci si aspetta dalla dimensione st corrispondente se il file contiene dei buchi).
La <code>st_blksize</code> è la dimensione ottimale del blocco (in byte) per l&rsquo;I/O sui file su questo file system. L&rsquo;I/O in blocchi più piccoli di questa dimensione è meno efficiente. Un tipico valore restituito in <code>st_blksize</code> è 4096.</p><h4 id=permessi-dei-file-e-tipo-di-file>Permessi dei file e tipo di file</h4><p>Il campo <code>st_mode</code> è una maschera di bit che serve al doppio scopo di identificare il tipo di file e specificare i permessi del file.</p><p>Il tipo di file può essere estratto da questo campo tramite AND (&) con la costante <code>S_IFMT</code>, e poi confrontando il risultato con una serie di costanti. Poiché questa è un&rsquo;operazione comune, vengono fornite delle macro standard.</p><table><thead><tr><th>Costante</th><th>Macro di test</th><th>Tipo di file</th></tr></thead><tbody><tr><td><code>S_IFREG</code></td><td><code>S_ISREG()</code></td><td>File normale</td></tr><tr><td><code>S_IFDIR</code></td><td><code>S_ISDIR()</code></td><td>Cartella</td></tr><tr><td><code>S_IFCHR</code></td><td><code>S_ISCHR()</code></td><td>Character Device</td></tr><tr><td><code>S_IFBLK</code></td><td><code>S_ISBLK()</code></td><td>Block device</td></tr><tr><td><code>S_IFIFO</code></td><td><code>S_ISFIFO()</code></td><td>FIFO oppure PIPE</td></tr><tr><td><code>S_IFSOCK</code></td><td><code>S_ISSOCK()</code></td><td>Socket</td></tr><tr><td><code>S_IFLNK</code></td><td><code>S_ISLNK()</code></td><td>Collegamento</td></tr></tbody></table><details><summary><b>Esempio di come controllare se un file è un file normale</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>char</span> <span class=n>pathname</span><span class=p>[]</span> <span class=o>=</span> <span class=s>&#34;/tmp/file.txt&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>stat</span> <span class=n>statbuf</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// Getting the attributes of /tmp/file.txt
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>stat</span><span class=p>(</span><span class=n>pathname</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>statbuf</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>errExit</span><span class=p>(</span><span class=s>&#34;stat&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// Checking if /tmp/file.txt is a regular file
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>((</span><span class=n>statbuf</span><span class=p>.</span><span class=n>st_mode</span> <span class=o>&amp;</span> <span class=n>S_IFMT</span><span class=p>)</span> <span class=o>==</span> <span class=n>S_IFREG</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>printf</span><span class=p>(</span><span class=s>&#34;regular file!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// Equivalently, checking if /tmp/file.txt is a // regular file by S_ISREG macro.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>S_ISREG</span><span class=p>(</span><span class=n>statbuf</span><span class=p>.</span><span class=n>st_mode</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;regular file!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span></span></span></code></pre></div></details><p><img src=../../images/lezioni/1/permissions.png alt="Permessi dei file"></p><p>I bit nominati <code>U</code> e G sono utilizzati per gli eseguibili.</p><ul><li>set-user-ID: se è impostato, allora l&rsquo;effective user ID del processo è uguale a quello del proprietario dell&rsquo;eseguibile</li><li>set-group-ID: se impostato, allora l&rsquo;effective group ID del processo è uguale a quello del proprietario dell&rsquo;eseguibile</li></ul><p>Il bit nominato <code>T</code>, chimato Sticky-bit, agisce come flag di cancellazione limitata per le directory.</p><p>Impostare questo bit su una directory significa che un processo senza privilegi può scollegare (<code>unlink()</code>, <code>rmdir()</code>) e rinominare (<code>rename()</code>) i file nella directory solo se ha il permesso di scrittura sulla directory e possiede il file o la directory.</p><p>I restanti 9 bit formano la maschera che definisce i permessi che sono concessi alle varie categorie di utenti che accedono al file. La maschera dei permessi del file divide il &ldquo;mondo&rdquo; in tre categorie:</p><ul><li>Proprietario: i permessi concessi al proprietario del file.</li><li>Gruppo: I permessi concessi agli utenti che sono membri del gruppo del file.</li><li>Altro: I permessi concessi a tutti gli altri.</li></ul><p>Ad ogni categoria di utenti possono essere concessi tre permessi:</p><ul><li>Lettura: Il contenuto del file può essere letto.</li><li>Scrittura: Il contenuto del file può essere modificato.</li><li>Esecuzione: Il file può essere eseguito.</li></ul><p>Le cartelle hanno lo stesso schema di permessi dei file. Tuttavia, i tre permessi sono interpretati in modo diverso:</p><ul><li>Lettura: Il contenuto (cioè l&rsquo;elenco dei nomi dei file) della directory può essere elencato</li><li>Scrittura: I file possono essere creati e rimossi dalla directory</li><li>Esecuzione: Si può accedere ai file all&rsquo;interno della directory.</li></ul><p>Quando si accede a un file, il permesso di esecuzione è richiesto su tutte le directory elencate nel percorso.</p><p>Il file header <code>&lt;sys/stat.h></code> definisce delle costanti che possono essere controllate [tramite una AND (&)] con il <code>st_mode</code> della struttura stat per controllare se particolari bit di permesso sono impostati.</p><details><summary><b>Visualizzare i permesi di un utente associato ad un file</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>char</span> <span class=n>pathname</span><span class=p>[]</span> <span class=o>=</span> <span class=s>&#34;/tmp/file.txt&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>stat</span> <span class=n>statbuf</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// Getting the attributes for the executable /tmp/a.out
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>stat</span><span class=p>(</span><span class=n>pathname</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>statbuf</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>errExit</span><span class=p>(</span><span class=s>&#34;stat&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// printing out the user’s permissions
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>printf</span><span class=p>(</span><span class=s>&#34;user’s permissions: %c%c%c</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=n>statbuf</span><span class=p>.</span><span class=n>st_mode</span> <span class=o>&amp;</span> <span class=n>S_IRUSR</span><span class=p>)</span><span class=o>?</span> <span class=err>’</span><span class=n>r</span><span class=err>’</span> <span class=o>:</span> <span class=err>’</span><span class=o>-</span><span class=err>’</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=n>statbuf</span><span class=p>.</span><span class=n>st_mode</span> <span class=o>&amp;</span> <span class=n>S_IWUSR</span><span class=p>)</span><span class=o>?</span> <span class=err>’</span><span class=n>w</span><span class=err>’</span> <span class=o>:</span> <span class=err>’</span><span class=o>-</span><span class=err>’</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=n>statbuf</span><span class=p>.</span><span class=n>st_mode</span> <span class=o>&amp;</span> <span class=n>S_IXUSR</span><span class=p>)</span><span class=o>?</span> <span class=err>’</span><span class=n>x</span><span class=err>’</span> <span class=o>:</span> <span class=err>’</span><span class=o>-</span><span class=err>’</span><span class=p>);</span></span></span></code></pre></div></details><h4 id=access>access</h4><p>La chiamata di sistema access verifica l&rsquo;accessibilità del file specificato nel pathname in base ai reali ID utente e gruppo di un processo. Se il pathname è un collegamento simbolico, access lo dereferenzia. L&rsquo;argomento mode è una maschera di bit composta da una o più delle seguenti costanti:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// Returns 0 if all permissions are granted, otherwise -1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>access</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>pathname</span><span class=p>,</span> <span class=kt>int</span> <span class=n>mode</span><span class=p>)</span></span></span></code></pre></div><table><thead><tr><th>Costanti</th><th>Descrizione</th></tr></thead><tbody><tr><td>F_OK</td><td>Il file esiste?</td></tr><tr><td>R_OK</td><td>Il file può essere letto?</td></tr><tr><td>W_OK</td><td>Il file può essere scritto?</td></tr><tr><td>X_OK</td><td>Il file può essere eseguito?</td></tr></tbody></table><details><summary><b>Controllare l'accesso di un file</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>char</span> <span class=n>pathname</span><span class=p>[]</span> <span class=o>=</span> <span class=s>&#34;/tmp/file.txt&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// Checking if /tmp/file.txt exists, can be read and
</span></span></span><span class=line><span class=cl><span class=c1>// written by the current process.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>access</span><span class=p>(</span><span class=n>pathname</span><span class=p>,</span> <span class=n>F_OK</span> <span class=o>|</span> <span class=n>R_OK</span> <span class=o>|</span> <span class=n>W_OK</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>printf</span><span class=p>(</span><span class=s>&#34; It looks like that I cannot read/write file.txt :(</span><span class=se>\n</span><span class=s>)&#34;</span><span class=p>)</span></span></span></code></pre></div></details><h3 id=cambiare-i-permessi-ad-un-file>Cambiare i permessi ad un file</h3><h4 id=chmod>chmod</h4><p>La system call chmod consente di cambiare i permessi ad un file. Prende in input pathname che è il nome del file e mode_t che sono i nuovi permessi del file.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/stat.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>chmod</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>pathname</span><span class=p>,</span> <span class=n>mode_t</span> <span class=n>mode</span><span class=p>);</span></span></span></code></pre></div><h4 id=fchmod>fchmod</h4><p>Uguale alla chmod, prende in input il file descriptor, al posto del pathname.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// All return 0 on success, or -1 on error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define _BSD_SOURCE
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/stat.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>fchmod</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=n>mode_t</span> <span class=n>mode</span><span class=p>);</span></span></span></code></pre></div><details><summary><b>Cambiare permessi ad un file</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>char</span> <span class=n>pathname</span><span class=p>[]</span> <span class=o>=</span> <span class=s>&#34;/tmp/file.txt&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>stat</span> <span class=n>sb</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>stat</span><span class=p>(</span><span class=n>pathname</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>sb</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>errExit</span><span class=p>(</span><span class=s>&#34;stat&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// Owner-write on, other-read off, remaining bits unchanged.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>mode_t</span> <span class=n>mode</span> <span class=o>=</span> <span class=p>(</span><span class=n>sb</span><span class=p>.</span><span class=n>st_mode</span> <span class=o>|</span> <span class=n>S_IWUSR</span><span class=p>)</span> <span class=o>&amp;</span> <span class=o>~</span><span class=n>S_IROTH</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>chmod</span><span class=p>(</span><span class=n>pathname</span><span class=p>,</span> <span class=n>mode</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>errExit</span><span class=p>(</span><span class=s>&#34;chmod&#34;</span><span class=p>);</span></span></span></code></pre></div></details><h2 id=cartelle>Cartelle</h2><h3 id=operazioni>Operazioni</h3><h4 id=mkdir>mkdir</h4><p>La chiamata di sistema mkdir crea una nuova directory.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/stat.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// Restituisce 0 in caso di successo, o -1 in caso di errore.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>mkdir</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>pathname</span><span class=p>,</span> <span class=n>mode_t</span> <span class=n>mode</span><span class=p>);</span></span></span></code></pre></div><p>L&rsquo;argomento <code>pathname</code> specifica il nome del percorso della nuova directory. Questo percorso può essere relativo o assoluto. Se un file con questo nome di percorso esiste già, allora la chiamata fallisce con l&rsquo;errore <code>EEXIST</code>. L&rsquo;argomento mode specifica i permessi per la nuova directory (vedi <a href=/oslab/lezioni/1-b-file-system/#apertura-file-open>System Call open</a>).</p><h4 id=rmdir>rmdir</h4><p>La chiamata di sistema rmdir rimuove una directory.<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// Restituisce 0 in caso di successo, o -1 in caso di errore.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>rmdir</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>pathname</span><span class=p>);</span></span></span></code></pre></div></p><p>Affinché rmdir abbia successo, la directory deve essere vuota. Se il componente finale di pathname è un collegamento simbolico, non viene dereferenziato; invece, risulta l&rsquo;errore ENOTDIR.</p><details><summary><b>Crea ed elimina una cartella</b></summary>
// Create a new directory with name myDir.
int res = mkdir(&ldquo;myDir&rdquo;, S_IRUSR | S_IXUSR);
if (res == 0) {
printf(&ldquo;The directory myDir was created!\n&rdquo;);
// Remove the directory with name myDir.
res = rmdir(&ldquo;myDir&rdquo;);
if (res == 0)
printf(&ldquo;The directory myDir was removed!\n&rdquo;);
}</details><h3 id=opendir-e-closedir>Opendir e closedir</h3><p>Le chiamate di sistema opendir e closedir aprono e chiudono rispettivamente una directory.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/types.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;dirent.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// Returns directory stream handle, or NULL on error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>DIR</span> <span class=o>*</span><span class=nf>opendir</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>dirpath</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// Returns 0 on success, or -1 on error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>closedir</span><span class=p>(</span><span class=n>DIR</span> <span class=o>*</span><span class=n>dirp</span><span class=p>);</span></span></span></code></pre></div><h3 id=readdir>Readdir</h3><p>La chiamata di sistema readdir legge il contenuto di una directory.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/types.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;dirent.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// Returns pointer to an allocated structure describing the
</span></span></span><span class=line><span class=cl><span class=c1>// next directory entry, or NULL on end-of-directory or error.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>dirent</span> <span class=o>*</span><span class=nf>readdir</span><span class=p>(</span><span class=n>DIR</span> <span class=o>*</span><span class=n>dirp</span><span class=p>);</span></span></span></code></pre></div><p>Ogni chiamata a readdir legge la prossima voce di file/directory dal flusso di directory a cui fa riferimento <code>dirp</code>. Ogni voce è una struct <code>dirent</code> definita come segue:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>dirent</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>ino_t</span> <span class=n>d_ino</span><span class=p>;</span> <span class=c1>// Numero di i-nodo del file. 
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>unsigned</span> <span class=kt>char</span> <span class=n>d_type</span><span class=p>;</span> <span class=c1>// Tipo di file.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>char</span> <span class=n>d_name</span><span class=p>[</span><span class=mi>256</span><span class=p>];</span> <span class=c1>// Nome del file con terminazione null.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></div><p>La libreria C definisce le seguenti costanti macro per il valore restituito nel tipo d:</p><table><thead><tr><th>Constante</th><th>Tipo di file</th></tr></thead><tbody><tr><td><code>DT_BLK</code></td><td>Block device</td></tr><tr><td><code>DT_CHR</code></td><td>Character device</td></tr><tr><td><code>DT_DIR</code></td><td>Directory</td></tr><tr><td><code>DT_FIFO</code></td><td>Named pipe (FIFO)</td></tr><tr><td><code>DT_LNK</code></td><td>Collegamento</td></tr><tr><td><code>DT_REG</code></td><td>File normale</td></tr><tr><td><code>DT_SOCK</code></td><td>Unix socket</td></tr></tbody></table><details><summary><b>Mostrare i file all'interno di una cartella</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>DIR</span> <span class=o>*</span><span class=n>dp</span> <span class=o>=</span> <span class=n>opendir</span><span class=p>(</span><span class=s>&#34;myDir&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>dp</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>errno</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>dirent</span> <span class=o>*</span><span class=n>dentry</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// Iterate until NULL is returned as a result.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>while</span> <span class=p>(</span> <span class=p>(</span><span class=n>dentry</span> <span class=o>=</span> <span class=n>readdir</span><span class=p>(</span><span class=n>dp</span><span class=p>))</span> <span class=o>!=</span> <span class=nb>NULL</span> <span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>dentry</span><span class=o>-&gt;</span><span class=n>d_type</span> <span class=o>==</span> <span class=n>DT_REG</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Regular file: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>dentry</span><span class=o>-&gt;</span><span class=n>d_name</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=n>errno</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// NULL is returned on error, and when the end-of-directory is reached!
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>errno</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>printf</span><span class=p>(</span><span class=s>&#34;Error while reading dir.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>closedir</span><span class=p>(</span><span class=n>dp</span><span class=p>);</span></span></span></code></pre></div></details><footer><p>Contenuto basato sulle slide del corso di Sistemi Operativi A.A Laboratorio 2021-2022 UniVR. Copyright degli autori delle slide originali.
<a href=https://github.com/seekbytes/oslab/edit/main/content/lezioni/1_concetti_fondamentali_filesystem.md>Modifica questa pagina</a></p></footer></div></body></html>