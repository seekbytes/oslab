<!doctype html><html lang=it><head><meta charset=utf-8><meta name=author content="SeekBytes"><meta name=viewport content="width=device-width,initial-scale=1"><title>Lezione 4.A - IPC e Semafori</title><link href=https://seekbytes.github.io/oslab/css/style.css rel=stylesheet type=text/css><link href=https://seekbytes.github.io/oslab/css/syntax.css rel=stylesheet type=text/css><link href=https://seekbytes.github.io/oslab/css/print.css rel=stylesheet media=print type=text/css><meta name=description content="SystemV, come comunicare con i semafori (apertura, chiusura, gestione e incremento/decremento)."><meta property="og:locale" content="it"><meta name=robots content="index,follow"><meta name=googlebot content="index,follow"></head><body class=flex><div class=navbar-lat><div class=links><h2>Indice</h2><nav id=TableOfContents><ul><li><a href=#introduzione-alla-comunicazione-tra-processi>Introduzione alla comunicazione tra processi</a><ul><li><a href=#creazione-e-apertura>Creazione e apertura</a></li><li><a href=#ipc_private>IPC_PRIVATE</a></li><li><a href=#ftok>Ftok</a></li></ul></li><li><a href=#strutture-dati>Strutture dati</a></li><li><a href=#comandi-ipc>Comandi IPC</a><ul><li><a href=#ipcs>ipcs</a></li><li><a href=#ipcrm>ipcrm</a></li></ul></li><li><a href=#semafori>Semafori</a><ul><li><a href=#creazione-e-apertura-1>Creazione e apertura</a></li><li><a href=#operazioni-di-controllo-del-semaforo>Operazioni di controllo del semaforo</a><ul><li><a href=#operazioni-di-controllo>Operazioni di controllo</a></li></ul></li><li><a href=#altre-operazioni>Altre operazioni</a><ul><li><a href=#semop>SemOP</a></li></ul></li></ul></li></ul></nav><h3>Contenuti</h3><ul><li><a href=https://seekbytes.github.io/oslab/lezioni/0-sistemi-operativi-laboratorio/>Lezione 0 - Introduzione a Sistemi Operativi Laboratorio</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/1-a-concetti-fondamentali/>Lezione 1.A - Concetti fondamentali: Processi e Programmi</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/1-b-file-system/>Lezione 1.B - Concetti fondamentali: File System</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/2-processi/>Lezione 2 - Processi</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/3-mentos/>Lezione 3.A - Fondamentali di MentOS</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/3-b-mentos-scheduling/>Lezione 3.B - MentOS Scheduling</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/4-a-semafori-ipc/>Lezione 4.A - IPC e Semafori</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/4-b-segnali-ipc/>Lezione 4.B - IPC e Segnali</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/5-memoria-condivisa-coda-di-messaggi/>Lezione 5 - Memoria condivisa e coda di messaggi</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/6-pipe-fifo/>Lezione 6 - Pipe e FIFO</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/7-a-struttura-mentos/>Lezione 7.A - Struttura di MentOS</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/7-b-mentos-system-call/>Lezione 7.B - System Call MentOS</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/7-c-mentos-deadlock/>Lezione 7.C - MentOS Deadlock</a></li><li><a href=https://seekbytes.github.io/oslab/lezioni/8-mentos-buddy-system/>Lezione 8 - MentOS Buddy System</a></li></ul><a href=../>Sezione principale</a></div></div><div class=content><a href=https://seekbytes.github.io/oslab/ id=returnBack>Ritorna indietro</a><h1>Lezione 4.A - IPC e Semafori</h1><p class=details>Pubblicato il 1/10/22 da SeekBytes – 2618 parole</p><div class=definition><h3>Definizione di Unix System V</h3>Unix System V è una delle prime versioni commerciali del sistema operativo Unix del sistema operativo Unix. È stato originariamente sviluppato da AT&T e rilasciato per la prima volta nel 1983. Sono state rilasciate quattro versioni principali di System V, numerate 1, 2, 3, e 4. SystemV è talvolta abbreviato in SysV.</div><div class=definition><h3>Definizione di Comunicazione Tra Processi</h3>La comunicazione interprocesso (IPC) si riferisce a meccanismi che coordinano le attività tra processi cooperanti. Un esempio comune di questa necessità è la gestione dell&rsquo;accesso a una data risorsa di sistema.</div><h2 id=introduzione-alla-comunicazione-tra-processi>Introduzione alla comunicazione tra processi</h2><p>System V IPCs si riferisce a tre diversi meccanismi per la comunicazione interprocesso
comunicazione:</p><ul><li>I semafori permettono ai processi di sincronizzare le loro azioni. Un semaforo è un valore mantenuto dal kernel, che è opportunamente modificato da processi del sistema prima di eseguire alcune azioni critiche</li><li>Le code di messaggi possono essere utilizzate per passare messaggi tra i processi.</li><li>La memoria condivisa permette a più processi di condividere una loro regione di memoria.</li></ul><p>Altri tipi di IPC includono:</p><ul><li>Segnali</li><li>Pipe</li><li>FIFO</li></ul><h3 id=creazione-e-apertura>Creazione e apertura</h3><p>Ogni meccanismo IPC di System V ha una chiamata di sistema associata get (<code>msgget</code>, <code>semget</code>, o <code>shmget</code>), che è analoga alla chiamata di sistema open. Data una chiave intera (analoga ad un nome di file), la chiamata di sistema get può creare prima un nuovo IPC e poi restituire il suo identificatore unico, oppure restituire l&rsquo;identificatore di un IPC esistente. Un identificatore IPC è analogo ad un descrittore di file. Viene usato in tutte le successive chiamate di sistema per riferirsi all&rsquo;oggetto IPC.</p><details><summary><b>Esempio: creare un semaforo</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// PERM: rw-------
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>id</span> <span class=o>=</span> <span class=nf>semget</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=mi>10</span> <span class=p>,</span><span class=n>IPC_CREAT</span> <span class=o>|</span> <span class=n>S_IRUSR</span> <span class=o>|</span> <span class=n>S_IWUSR</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>id</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nf>errExit</span><span class=p>(</span><span class=n>semget</span><span class=p>);</span></span></span></code></pre></div></details><p>Come per tutte le chiamate get, la chiave è il primo argomento. È un valore sensibile per l&rsquo;applicazione che usa l&rsquo;oggetto IPC. L&rsquo;identificatore IPC restituito è un codice unico che identifica l&rsquo;oggetto IPC nel sistema. Mappatura con la chiamata di sistema open(&mldr;): key -> nome del file, id ->file descriptor.</p><p>Le chiavi IPC di SystemV sono valori interi rappresentati utilizzando il tipo di dati key_t. Le chiamate IPC get traducono una chiave nel corrispondente identificatore intero identificatore IPC. Quindi, come possiamo fornire una chiave unica che ci garantisca di non ottenere accidentalmente l&rsquo;identificatore di un oggetto IPC esistente usato da qualche altra applicazione?</p><h3 id=ipc_private>IPC_PRIVATE</h3><p>Quando si crea un nuovo oggetto IPC, la chiave può essere specificata come <code>IPC_PRIVATE</code>.
In questo modo, si delega il problema di trovare una chiave unica al kernel.
Esempio di utilizzo di <code>IPC_PRIVATE</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>id</span> <span class=o>=</span> <span class=nf>semget</span><span class=p>(</span><span class=n>IPC_PRIVATE</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=n>S_IRUSR</span> <span class=o>|</span> <span class=n>S_IWUSR</span><span class=p>);</span></span></span></code></pre></div><p>Questa tecnica è particolarmente utile in applicazioni multiprocesso dove il processo padre crea l&rsquo;oggetto IPC prima di eseguire un <code>fork()</code>, con il risultato che il processo figlio eredita l&rsquo;identificatore dell&rsquo;oggetto IPC.</p><h3 id=ftok>Ftok</h3><p>La funzione ftok (file to key) converte un <code>pathname</code> e un proj_id (cioè identificatore di progetto) in una chiave IPC.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/ipc.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// Returns integer key on succcess, or -1 on error (check errno)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>key_t</span> <span class=nf>ftok</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>pathname</span><span class=p>,</span> <span class=kt>int</span> <span class=n>proj_id</span><span class=p>);</span></span></span></code></pre></div><p>Il percorso fornito deve riferirsi a un file esistente e accessibile. Gli ultimi 8 bit del <code>proj_id</code> sono effettivamente utilizzati, e devono essere un valore non nullo. Tipicamente, il <code>pathname</code> si riferisce ad uno dei file, o directory, creati dall&rsquo;applicazione.</p><details><summary><b>Esempio di utilizzo della funzione ftok</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>key_t</span> <span class=n>key</span> <span class=o>=</span> <span class=nf>ftok</span><span class=p>(</span><span class=s>&#34;/mydir/myfile&#34;</span><span class=p>,</span> <span class=err>’</span><span class=n>a</span><span class=err>’</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>key</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>errExit</span><span class=p>(</span><span class=s>&#34;ftok failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>id</span> <span class=o>=</span> <span class=nf>semget</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=n>S_IRUSR</span> <span class=o>|</span> <span class=n>S_IWUSR</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>id</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>errExit</span><span class=p>(</span><span class=s>&#34;semget failed&#34;</span><span class=p>);</span></span></span></code></pre></div>Esempio: carattere 'a':
* ASCII = 097
* Binario = 01100001</details><h2 id=strutture-dati>Strutture dati</h2><p>Il kernel mantiene una struttura dati associata (<code>msqid_ds</code>, <code>semid_ds</code>, <code>shmid_ds</code>) per ogni istanza di un oggetto System V IPC. Oltre ai dati specifici al tipo di oggetto IPC, ogni struttura dati associata include la sottostruttura ipc_perm che contiene i permessi concessi.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>ipc_perm</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>key_t</span> <span class=n>__key</span><span class=p>;</span> <span class=cm>/* Key, as supplied to ’get’ call */</span>
</span></span><span class=line><span class=cl>	<span class=kt>uid_t</span> <span class=n>uid</span><span class=p>;</span> <span class=cm>/* Owner’s user ID */</span>
</span></span><span class=line><span class=cl>	<span class=kt>gid_t</span> <span class=n>gid</span><span class=p>;</span> <span class=cm>/* Owner’s group ID */</span>
</span></span><span class=line><span class=cl>	<span class=kt>uid_t</span> <span class=n>cuid</span><span class=p>;</span> <span class=cm>/* Creator’s user ID */</span>
</span></span><span class=line><span class=cl>	<span class=kt>gid_t</span> <span class=n>cgid</span><span class=p>;</span> <span class=cm>/* Creator’s group ID */</span>
</span></span><span class=line><span class=cl>	<span class=kt>unsigned</span> <span class=kt>short</span> <span class=n>mode</span><span class=p>;</span> <span class=cm>/* Permissions */</span>
</span></span><span class=line><span class=cl>	<span class=kt>unsigned</span> <span class=kt>short</span> <span class=n>__seq</span><span class=p>;</span> <span class=cm>/* Sequence number */</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></div><p>Alcune note:</p><ul><li>I campi <code>uid</code> e <code>gid</code> specificano la proprietà dell&rsquo;oggetto IPC.</li><li>I campi <code>cuid</code> e <code>cgid</code> contengono gli ID utente e gruppo del processo che ha creato l&rsquo;oggetto.</li><li>Il campo <code>mode</code> contiene la maschera dei permessi per l&rsquo;oggetto IPC, che sono inizializzati usando i 9 bit inferiori dei flag specificati nella chiamata di sistema get usata per creare l&rsquo;oggetto.</li></ul><p>Alcune note importanti su <code>ipc_perm</code>:</p><ul><li>I campi <code>cuid</code> e <code>cgid</code> sono immutabili.</li><li>Solo i permessi di lettura e scrittura sono significativi per gli oggetti IPC. Il permesso di esecuzione è privo di significato e viene ignorato.</li></ul><details><summary><b>Esempio tipico di semctl per cambiare il proprietario di un semaforo</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>semid_ds</span> <span class=n>semq</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// get the data structure of a semaphore from the kernel
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=nf>semctl</span><span class=p>(</span><span class=n>semid</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>IPC_STAT</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>semq</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>errExit</span><span class=p>(</span><span class=s>&#34;semctl get failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// change the owner of the semaphore
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>semq</span><span class=p>.</span><span class=n>sem_perm</span><span class=p>.</span><span class=n>uid</span> <span class=o>=</span> <span class=n>newuid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// update the kernel copy of the data structure
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=nf>semctl</span><span class=p>(</span><span class=n>semid</span><span class=p>,</span> <span class=n>IPC_SET</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>semq</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>errExit</span><span class=p>(</span><span class=s>&#34;semctl set failed&#34;</span><span class=p>);</span></span></span></code></pre></div>Allo stesso modo, le chiamate di sistema shmctl e msgctl sono applicate per aggiornare la struttura dati del kernel di una memoria condivisa e della coda dei messaggi.</details><h2 id=comandi-ipc>Comandi IPC</h2><h3 id=ipcs>ipcs</h3><p>Usando ipcs, possiamo ottenere informazioni sugli oggetti IPC nel sistema. Per impostazione predefinita, ipcs visualizza tutti gli oggetti, come nel seguente esempio:</p><details><summary><b>Esmepio ipcs</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>user@localhost<span class=o>[</span>~<span class=o>]</span>$ ipcs
</span></span><span class=line><span class=cl>------ Message Queues --------
</span></span><span class=line><span class=cl>key		msqid	Owner		perms 	used-bytes 	messages
</span></span><span class=line><span class=cl>0x1235 	26		student 	<span class=m>620</span> 	<span class=m>12</span> 			<span class=m>20</span>
</span></span><span class=line><span class=cl>------ Shared Memory Segments --------
</span></span><span class=line><span class=cl>key		msqid	Owner		perms 	bytes 	messages
</span></span><span class=line><span class=cl>0x1234 	<span class=m>0</span> 		professor 	<span class=m>600</span> 	<span class=m>8192</span> 	<span class=m>2</span>
</span></span><span class=line><span class=cl>------ Semaphore Arrays --------
</span></span><span class=line><span class=cl>key		semid	Owner		perms 	nsems
</span></span><span class=line><span class=cl>0x1111 	102		professor 	<span class=m>330</span> 	<span class=m>20</span></span></span></code></pre></div></details><h3 id=ipcrm>ipcrm</h3><p>Usando <code>ipcrm</code>, possiamo rimuovere gli oggetti IPC dal sistema.</p><details><summary><b>Rimuovere una coda di messaggi</b></summary><pre tabindex=0><code>ipcrm -Q 0x1235 ( 0x1235 is the key of a queue )
ipcrm -q 26 ( 26 is the identifier of a queue )
</code></pre></details><details><summary><b>Rimuovere un segmento di memoria condivisa</b></summary><pre tabindex=0><code>ipcrm -M 0x1234 ( 0x1234 is the key of a shared memory seg. )
ipcrm -m 0 ( 0 is the identifier of a shared memory seg. )
</code></pre></details><details><summary><b>Rimuovere una serie di semafori</b></summary><pre tabindex=0><code>ipcrm -S 0x1111 ( 0x1111 is the key of a semaphore array )
ipcrm -s 102 ( 102 is the identifier of a semaphore array )
</code></pre></details><h2 id=semafori>Semafori</h2><h3 id=creazione-e-apertura-1>Creazione e apertura</h3><p>La chiamata di sistema <code>semget</code> crea un nuovo set di semafori o ottiene l&rsquo;identificatore di un set esistente.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/sem.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// Returns semaphore set identifier on success, or -1 error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>semget</span><span class=p>(</span><span class=kt>key_t</span> <span class=n>key</span><span class=p>,</span> <span class=kt>int</span> <span class=n>nsems</span><span class=p>,</span> <span class=kt>int</span> <span class=n>semflg</span><span class=p>);</span></span></span></code></pre></div><p>Gli argomenti chiave sono: una chiave IPC, <code>nsems</code> specifica il numero di semafori in quell&rsquo;insieme e deve essere maggiore di 0. <code>semflg</code> è una maschera di bit che specifica i permessi (vedi la chiamata di sistema open(&mldr;), argomento mode) da essere posti su un nuovo insieme di semafori o controllati su un insieme esistente.</p><p>In aggiunta, i seguenti flag possono essere ORed (<code>|</code>) in semflg:</p><ul><li><code>IPC_CREAT</code>: se non esiste un insieme di semafori con la chiave specificata, crea un
nuovo insieme di semafori.</li><li><code>IPC_EXCL</code>: in combinazione con IPC CREAT, fa fallire semget se un set di semafori esiste con la chiave specificata.</li></ul><details><summary><b>Esempio per creare un insieme di 10 semafori</b></summary>
int semid;
ket_t key = //&mldr; (generate a key in some way, i.e. with ftok)
// A) delegate the problem of finding a unique key to the kernel
semid = semget(IPC_PRIVATE, 10, S_IRUSR | S_IWUSR);
// B) create a semaphore set with identifier key, if it doesn’t already exist
semid = semget(key, 10, IPC_CREAT | S_IRUSR | S_IWUSR);
//C) create a semaphore set with identifier key, but fail if it exists already
semid = semget(key, 10, IPC_CREAT | IPC_EXCL | S_IRUSR | S_IWUSR);</details><h3 id=operazioni-di-controllo-del-semaforo>Operazioni di controllo del semaforo</h3><p>La chiamata di sistema semctl esegue una varietà di operazioni di controllo su un semaforo o su un singolo semaforo all&rsquo;interno di un insieme.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/sem.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// Returns nonnegative integer on success, or -1 error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>semctl</span><span class=p>(</span><span class=kt>int</span> <span class=n>semid</span><span class=p>,</span> <span class=kt>int</span> <span class=n>semnum</span><span class=p>,</span> <span class=kt>int</span> <span class=n>cmd</span><span class=p>,</span> <span class=p>...</span> <span class=cm>/* union semun arg */</span><span class=p>);</span></span></span></code></pre></div><p>L&rsquo;argomento semid è l&rsquo;identificatore dell&rsquo;insieme di semafori su cui l&rsquo;operazione operazione deve essere eseguita. Alcune operazioni di controllo (cmd) richiedono un terzo/quarto argomento. Prima che presentare le operazioni di controllo disponibili su un insieme di semafori, viene introdotta l&rsquo;unione <code>semun</code> viene introdotta.</p><p>L&rsquo;unione semun deve essere esplicitamente definita dal programmatore prima di chiamare la syscall <code>semctl</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#ifndef SEMUN_H
</span></span></span><span class=line><span class=cl><span class=cp>#define SEMUN_H
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/sem.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// definition of the union semun
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>union</span> <span class=n>semun</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>semid_ds</span> <span class=o>*</span><span class=n>buf</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>unsigned</span> <span class=kt>short</span> <span class=o>*</span><span class=n>array</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=cp>#endif</span></span></span></code></pre></div><h4 id=operazioni-di-controllo>Operazioni di controllo</h4><ul><li><p><code>IPC_RMID</code>: rimuovere immediatamente il semaforo impostato. Qualsiasi processo bloccato viene risvegliato (errore impostato su EIDRM). L&rsquo;argomento arg non è richiesto.</p></li><li><p><code>IPC_STAT</code>: posiziona una copia della struttura dati semid ds associata a questo set di semafori nel buffer indicato da arg.buf.</p></li><li><p><code>ICP_SET</code>: Aggiorna i campi selezionati della struttura dati semids associata a questo set di semafori usando i valori nel buffer puntato da arg.buf.</p></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>semid_ds</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>ipc_perm</span> <span class=n>sem_perm</span><span class=p>;</span> <span class=cm>/* Ownership and permissions */</span>
</span></span><span class=line><span class=cl>	<span class=kt>time_t</span> <span class=n>sem_otime</span><span class=p>;</span> <span class=cm>/* Time of last semop() */</span>
</span></span><span class=line><span class=cl>	<span class=kt>time_t</span> <span class=n>sem_ctime</span><span class=p>;</span> <span class=cm>/* Time of last change */</span>
</span></span><span class=line><span class=cl>	<span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>sem_nsems</span><span class=p>;</span> <span class=cm>/* Number of semaphores in set */</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></div><p>Solo i sottocampi <code>uid</code>, <code>gid</code> e <code>mode</code> della sottostruttura <code>sem_perm</code> possono essere aggiornati tramite <code>IPC_SET</code>.</p><details><summary><b>Esempio riguardo il cambio di permessi di un insieme di semafori</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>ket_t</span> <span class=n>key</span> <span class=o>=</span> <span class=c1>//... (generate a key in some way, i.e. with ftok)
</span></span></span><span class=line><span class=cl><span class=c1>// get, or create, the semaphore set
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>semid</span> <span class=o>=</span> <span class=nf>semget</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=n>IPC_CREAT</span> <span class=o>|</span> <span class=n>S_IRUSR</span> <span class=o>|</span> <span class=n>S_IWUSR</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// instantiate a semid_ds struct
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>semid_ds</span> <span class=n>ds</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// instantiate a semun union (defined manually somewhere)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>union</span> <span class=n>semun</span> <span class=n>arg</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>arg</span><span class=p>.</span><span class=n>buf</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>ds</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// get a copy of semid_ds structure belonging to the kernel
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=nf>semctl</span><span class=p>(</span><span class=n>semid</span><span class=p>,</span> <span class=mi>0</span> <span class=cm>/*ignored*/</span><span class=p>,</span> <span class=n>IPC_STAT</span><span class=p>,</span> <span class=n>arg</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>errExit</span><span class=p>(</span><span class=s>&#34;semctl IPC_STAT failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// update permissions to guarantee read access to the group
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>arg</span><span class=p>.</span><span class=n>buf</span><span class=o>-&gt;</span><span class=n>sem_perms</span><span class=p>.</span><span class=n>mode</span> <span class=o>|=</span> <span class=n>S_IRGRP</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// update the semid_ds structure of the kernel
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=nf>semctl</span><span class=p>(</span><span class=n>semid</span><span class=p>,</span> <span class=mi>0</span> <span class=cm>/*ignored*/</span><span class=p>,</span> <span class=n>IPC_SET</span><span class=p>,</span> <span class=n>arg</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>errExit</span><span class=p>(</span><span class=s>&#34;semctl IPC_SET failed&#34;</span><span class=p>);</span></span></span></code></pre></div></details><details><summary><b>Esempio su come rimuovere un insieme di semafori</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=nf>semctl</span><span class=p>(</span><span class=n>semid</span><span class=p>,</span> <span class=mi>0</span><span class=cm>/*ignored*/</span><span class=p>,</span> <span class=n>IPC_RMID</span><span class=p>,</span> <span class=mi>0</span><span class=cm>/*ignored*/</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>errExit</span><span class=p>(</span><span class=s>&#34;semctl failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>else</span>
</span></span><span class=line><span class=cl>	<span class=nf>printf</span><span class=p>(</span><span class=s>&#34;semaphore set removed successfully</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span></span></span></code></pre></div></details><p>(..continuo..)</p><ul><li><p><code>SETVAL</code>: il valore del semaforo semnum-esimo nell&rsquo;insieme a cui si riferisce da semid è inizializzato al valore specificato in arg.val.</p></li><li><p><code>GETVAL</code>: come risultato della sua funzione, semctl restituisce il valore del semnum-esimo semaforo nell&rsquo;insieme di semafori specificato da semid. L&rsquo;argomento argomento arg non è richiesto.</p></li><li><p><code>SETALL</code>: inizializza tutti i semafori nell&rsquo;insieme a cui fa riferimento semid, usando i valori forniti nell&rsquo;array indicato da arg.array</p></li><li><p><code>GETALL</code>: recupera i valori di tutti i semafori nell&rsquo;insieme a cui da semid, mettendoli nell&rsquo;array indicato da arg.array</p></li></ul><details><summary><b>Esempio su come inizializzare un semaforo specifico in un insieme di semafori</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>ket_t</span> <span class=n>key</span> <span class=o>=</span> <span class=c1>//... (generate a key in some way, i.e. with ftok)
</span></span></span><span class=line><span class=cl><span class=c1>// get, or create, the semaphore set
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>semid</span> <span class=o>=</span> <span class=nf>semget</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=n>IPC_CREAT</span> <span class=o>|</span> <span class=n>S_IRUSR</span> <span class=o>|</span> <span class=n>S_IWUSR</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// set the semaphore value to 0
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>union</span> <span class=n>semun</span> <span class=n>arg</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>arg</span><span class=p>.</span><span class=n>val</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// initialize the 5-th semaphore to 0
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=nf>semctl</span><span class=p>(</span><span class=n>semid</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=n>SETVAL</span><span class=p>,</span> <span class=n>arg</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>errExit</span><span class=p>(</span><span class=s>&#34;semctl SETVAL&#34;</span><span class=p>);</span></span></span></code></pre></div></details><details><summary><b>Esempio su come recuperare lo stato corrente di un semaforo specifico in un insieme di semafori.</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>ket_t</span> <span class=n>key</span> <span class=o>=</span> <span class=c1>//... (generate a key in some way, i.e. with ftok)
</span></span></span><span class=line><span class=cl><span class=c1>// get, or create, the semaphore set
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>semid</span> <span class=o>=</span> <span class=nf>semget</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=n>IPC_CREAT</span> <span class=o>|</span> <span class=n>S_IRUSR</span> <span class=o>|</span> <span class=n>S_IWUSR</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// get the current state of the 5-th semaphore
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>value</span> <span class=o>=</span> <span class=nf>semctl</span><span class=p>(</span><span class=n>semid</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=n>GETVAL</span><span class=p>,</span> <span class=mi>0</span><span class=cm>/*ignored*/</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>value</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>errExit</span><span class=p>(</span><span class=s>&#34;semctl GETVAL&#34;</span><span class=p>);</span></span></span></code></pre></div></details><details><summary><b>Esempio su come inizializzare un insieme di semafori con 10 semafori</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>ket_t</span> <span class=n>key</span> <span class=o>=</span> <span class=c1>//... (generate a key in some way, i.e. with ftok)
</span></span></span><span class=line><span class=cl><span class=c1>// get, or create, the semaphore set
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>semid</span> <span class=o>=</span> <span class=nf>semget</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=n>IPC_CREAT</span> <span class=o>|</span> <span class=n>S_IRUSR</span> <span class=o>|</span> <span class=n>S_IWUSR</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// set the first 5 semaphores to 1, and the remaining to 0
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>values</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span><span class=mi>1</span><span class=p>,</span><span class=mi>1</span><span class=p>,</span><span class=mi>1</span><span class=p>,</span><span class=mi>1</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>union</span> <span class=n>semun</span> <span class=n>arg</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>arg</span><span class=p>.</span><span class=n>array</span> <span class=o>=</span> <span class=n>values</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// initialize the semaphore set
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=nf>semctl</span><span class=p>(</span><span class=n>semid</span><span class=p>,</span> <span class=mi>0</span><span class=cm>/*ignored*/</span><span class=p>,</span> <span class=n>SETALL</span><span class=p>,</span> <span class=n>arg</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>errExit</span><span class=p>(</span><span class=s>&#34;semctl SETALL&#34;</span><span class=p>);</span></span></span></code></pre></div></details><details><summary><b>Esempio su come recuperare l'insieme degli stati da un insieme di semafori.</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>ket_t</span> <span class=n>key</span> <span class=o>=</span> <span class=c1>//... (generate a key in some way, i.e. with ftok)
</span></span></span><span class=line><span class=cl><span class=c1>// get, or create, the semaphore set
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>semid</span> <span class=o>=</span> <span class=nf>semget</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=n>IPC_CREAT</span> <span class=o>|</span> <span class=n>S_IRUSR</span> <span class=o>|</span> <span class=n>S_IWUSR</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// declare an array big enougth to store the semaphores’ value
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>values</span><span class=p>[</span><span class=mi>10</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=k>union</span> <span class=n>semun</span> <span class=n>arg</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>arg</span><span class=p>.</span><span class=n>array</span> <span class=o>=</span> <span class=n>values</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// get the current state of a semaphore set
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=nf>semctl</span><span class=p>(</span><span class=n>semid</span><span class=p>,</span> <span class=mi>0</span><span class=cm>/*ignored*/</span><span class=p>,</span> <span class=n>GETALL</span><span class=p>,</span> <span class=n>arg</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nf>errExit</span><span class=p>(</span><span class=s>&#34;semctl GETALL&#34;</span><span class=p>);</span></span></span></code></pre></div></details><p>(..continuo..)</p><ul><li><code>GETPID</code>: restituisce l&rsquo;ID del processo dell&rsquo;ultimo processo che ha eseguito un semop sul semaforo semnum-esimo</li><li><code>GETNCNT</code>: restituisce il numero di processi attualmente in attesa che il valore del semaforo semnum-esimo per aumentare</li><li><code>GETZCNT</code>: restituisce il numero di processi attualmente in attesa del che il valore del semaforo semnum-esimo diventi 0;</li></ul><details><summary><b>Esempio su come recuperare informazioni di un semaforo da un insieme di semafori</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>ket_t</span> <span class=n>key</span> <span class=o>=</span> <span class=c1>//... (generate a key in some way, i.e. with ftok)
</span></span></span><span class=line><span class=cl><span class=c1>// get, or create, the semaphore set
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>semid</span> <span class=o>=</span> <span class=nf>semget</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=n>IPC_CREAT</span> <span class=o>|</span> <span class=n>S_IRUSR</span> <span class=o>|</span> <span class=n>S_IWUSR</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1>// get information about the first semaphore of the semaphore set
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Sem:%d getpid:%d getncnt:%d getzcnt:%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=n>semid</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=nf>semctl</span><span class=p>(</span><span class=n>semid</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>GETPID</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>),</span>
</span></span><span class=line><span class=cl><span class=nf>semctl</span><span class=p>(</span><span class=n>semid</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>GETNCNT</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>),</span>
</span></span><span class=line><span class=cl><span class=nf>semctl</span><span class=p>(</span><span class=n>semid</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>GETZCNT</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>));</span></span></span></code></pre></div></details><p><strong>UN INSIEME DI SEMAFORI DEVE ESSERE SEMPRE INIZIALIZZATO!</strong></p><h3 id=altre-operazioni>Altre operazioni</h3><h4 id=semop>SemOP</h4><p>La chiamata di sistema semop esegue una o più operazioni (wait (P) e signal (V)) sui semafori.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/sem.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// Returns 0 on success, or -1 on error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>semop</span><span class=p>(</span><span class=kt>int</span> <span class=n>semid</span><span class=p>,</span> <span class=k>struct</span> <span class=n>sembuf</span> <span class=o>*</span><span class=n>sops</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>nsops</span><span class=p>);</span></span></span></code></pre></div><p>L&rsquo;argomento <code>sops</code> è un puntatore a un array che contiene una sequenza ordinata di operazioni da eseguire <strong>atomicamente</strong>, e <code>nsops</code> (> 0) fornisce la dimensione di questo array. Gli elementi dell&rsquo;array <code>sops</code> sono strutture della seguente forma:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>sembuf</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>unsigned</span> <span class=kt>short</span> <span class=n>sem_num</span><span class=p>;</span> <span class=cm>/* Semaphore number */</span>
</span></span><span class=line><span class=cl>	<span class=kt>short</span> <span class=n>sem_op</span><span class=p>;</span> <span class=cm>/* Operation to be performed */</span>
</span></span><span class=line><span class=cl>	<span class=kt>short</span> <span class=n>sem_flg</span><span class=p>;</span> <span class=cm>/* Operation flags */</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></div><p>Il campo <code>sem_num</code> identifica il semaforo all&rsquo;interno dell&rsquo;insieme sul quale operazione deve essere eseguita. Il campo <code>sem_op</code> specifica l&rsquo;operazione da essere eseguita:</p><ul><li><code>sem_op > 0</code>: il valore del sem op viene aggiunto al valore del sem num-th semaforo.</li><li><code>sem_op = 0</code>: il valore del semaforo sem num-esimo viene controllato per vedere se è attualmente uguale a 0. Se non lo è, il processo chiamante è bloccato fino a quando il semaforo è 0.</li><li><code>sem_op &lt; 0</code>: diminuisce il valore del semaforo sem num-th della quantità specificata in sem op. blocca il processo chiamante fino a quando il valore del semaforo è stato aumentato ad un livello che permette di eseguire l&rsquo;operazione senza risultare in un valore negativo.</li></ul><p>Quando una chiamata semop(&mldr;) si blocca, il processo rimane bloccato fino a quando seguenti eventi:</p><ul><li>Un altro processo modifica il valore del semaforo in modo che l&rsquo;operazione l&rsquo;operazione richiesta possa procedere.</li><li>Un segnale interrompe la chiamata semop(&mldr;). In questo caso, l&rsquo;errore EINTR risulta.</li><li>Un altro processo cancella il semaforo a cui fa riferimento semid. In questo caso, semop(&mldr;) fallisce con l&rsquo;errore <code>EIDRM</code>.</li></ul><p>Possiamo evitare che semop(&mldr;) si blocchi quando esegue un&rsquo;operazione su un particolare semaforo specificando il flag <code>IPC_NOWAIT</code> nel campo sem_flg corrispondente. In questo caso, se semop(&mldr;) si sarebbe bloccato, invece fallisce con l&rsquo;errore <code>EAGAIN</code>.</p><details><summary><b>Esempio su come inizializzare un'array di operazioni sembuf</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>sembuf</span> <span class=n>sops</span><span class=p>[</span><span class=mi>3</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=n>sops</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>sem_num</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>sops</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>sem_op</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span> <span class=c1>// subtract 1 from semaphore 0
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>sops</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>sem_flg</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>sops</span><span class=p>[</span><span class=mi>1</span><span class=p>].</span><span class=n>sem_num</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>sops</span><span class=p>[</span><span class=mi>1</span><span class=p>].</span><span class=n>sem_op</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span> <span class=c1>// add 2 to semaphore 1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>sops</span><span class=p>[</span><span class=mi>1</span><span class=p>].</span><span class=n>sem_flg</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>sops</span><span class=p>[</span><span class=mi>2</span><span class=p>].</span><span class=n>sem_num</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>sops</span><span class=p>[</span><span class=mi>2</span><span class=p>].</span><span class=n>sem_op</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=c1>// wait for semaphore 2 to equal 0
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>sops</span><span class=p>[</span><span class=mi>2</span><span class=p>].</span><span class=n>sem_flg</span> <span class=o>=</span> <span class=n>IPC_NOWAIT</span><span class=p>;</span> <span class=c1>// but don’t block if operation cannot be
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>performed</span> <span class=n>immediately</span></span></span></code></pre></div></details><details><summary><b>Esempio su come eseguire operazioni su un insieme di semafori</b></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>sembuf</span> <span class=n>sops</span><span class=p>[</span><span class=mi>3</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=c1>// .. see the previous slide to initilize sembuf
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=nf>semop</span><span class=p>(</span><span class=n>semid</span><span class=p>,</span> <span class=n>sops</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>errno</span> <span class=o>==</span> <span class=n>EAGAIN</span><span class=p>)</span> <span class=c1>// Semaphore 2 would have blocked
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Operation would have blocked</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>else</span>
</span></span><span class=line><span class=cl>		<span class=nf>errExit</span><span class=p>(</span><span class=s>&#34;semop&#34;</span><span class=p>);</span> <span class=c1>// Some other error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></div></details><footer><p>Contenuto basato sulle slide del corso di Sistemi Operativi A.A Laboratorio 2021-2022 UniVR. Copyright degli autori delle slide originali.
<a href=https://github.com/seekbytes/oslab/edit/main/content/lezioni/4_a_semafori.md>Modifica questa pagina</a></p></footer></div></body></html>